define(["exports", "../../lit/index.js", "./vaadin-theme-property-mixin.js"], function (_exports, _index, _vaadinThemePropertyMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.__themeRegistry = _exports.ThemableMixin = void 0;
  Object.defineProperty(_exports, "css", {
    enumerable: true,
    get: function get() {
      return _index.css;
    }
  });
  _exports.registerStyles = registerStyles;
  Object.defineProperty(_exports, "unsafeCSS", {
    enumerable: true,
    get: function get() {
      return _index.unsafeCSS;
    }
  });

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  /**
   * @typedef {Object} Theme
   * @property {string} themeFor
   * @property {CSSResult[]} styles
   * @property {string | string[]} [include]
   * @property {string} [moduleId]
   *
   * @typedef {CSSResult[] | CSSResult} CSSResultGroup
   */

  /**
   * @type {Theme[]}
   */
  var themeRegistry = [];
  /**
   * Registers CSS styles for a component type. Make sure to register the styles before
   * the first instance of a component of the type is attached to DOM.
   *
   * @param {string} themeFor The local/tag name of the component type to register the styles for
   * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type
   * matching themeFor and included in the local scope of each component instance
   * @param {{moduleId?: string, include?: string | string[]}} options Additional options
   * @return {void}
   */

  _exports.__themeRegistry = themeRegistry;

  function registerStyles(themeFor, styles) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (themeFor) {
      var elementClass = customElements.get(themeFor);

      if (elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__finalized')) {
        console.warn("The custom element definition for \"".concat(themeFor, "\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element."));
      }
    }

    styles = recursiveFlattenStyles(styles);

    if (window.Vaadin && window.Vaadin.styleModules) {
      window.Vaadin.styleModules.registerStyles(themeFor, styles, options);
    } else {
      themeRegistry.push({
        themeFor: themeFor,
        styles: styles,
        include: options.include,
        moduleId: options.moduleId
      });
    }
  }
  /**
   * Returns all registered themes. By default the themeRegistry is returend as is.
   * In case the style-modules adapter is imported, the themes are obtained from there instead
   * @returns {Theme[]}
   */


  function getAllThemes() {
    if (window.Vaadin && window.Vaadin.styleModules) {
      return window.Vaadin.styleModules.getAllThemes();
    } else {
      return themeRegistry;
    }
  }
  /**
   * Returns true if the themeFor string matches the tag name
   * @param {string} themeFor
   * @param {string} tagName
   * @returns {boolean}
   */


  function matchesThemeFor(themeFor, tagName) {
    return (themeFor || '').split(' ').some(function (themeForToken) {
      return new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(tagName);
    });
  }
  /**
   * Maps the moduleName to an include priority number which is used for
   * determining the order in which styles are applied.
   * @param {string} moduleName
   * @returns {number}
   */


  function getIncludePriority() {
    var moduleName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var includePriority = 0;

    if (moduleName.indexOf('lumo-') === 0 || moduleName.indexOf('material-') === 0) {
      includePriority = 1;
    } else if (moduleName.indexOf('vaadin-') === 0) {
      includePriority = 2;
    }

    return includePriority;
  }
  /**
   * Flattens the styles into a single array of styles.
   * @param {CSSResultGroup} styles
   * @param {CSSResult[]} result
   * @returns {CSSResult[]}
   */


  function recursiveFlattenStyles() {
    var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (babelHelpers.instanceof(styles, _index.CSSResult)) {
      result.push(styles);
    } else if (Array.isArray(styles)) {
      styles.forEach(function (style) {
        return recursiveFlattenStyles(style, result);
      });
    } else {
      console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');
    }

    return result;
  }
  /**
   * Gets an array of CSSResults matching the include property of the theme.
   * @param {Theme} theme
   * @returns {CSSResult[]}
   */


  function getIncludedStyles(theme) {
    var includedStyles = [];

    if (theme.include) {
      [].concat(theme.include).forEach(function (includeModuleId) {
        var includedTheme = getAllThemes().find(function (s) {
          return s.moduleId === includeModuleId;
        });

        if (includedTheme) {
          includedStyles.push.apply(includedStyles, babelHelpers.toConsumableArray(getIncludedStyles(includedTheme)).concat(babelHelpers.toConsumableArray(includedTheme.styles)));
        } else {
          console.warn("Included moduleId ".concat(includeModuleId, " not found in style registry"));
        }
      }, theme.styles);
    }

    return includedStyles;
  }
  /**
   * Includes the styles to the template.
   * @param {CSSResult[]} styles
   * @param {HTMLTemplateElement} template
   */


  function addStylesToTemplate(styles, template) {
    var styleEl = document.createElement('style');
    styleEl.innerHTML = styles // Remove duplicates so that the last occurrence remains
    .filter(function (style, index) {
      return index === styles.lastIndexOf(style);
    }).map(function (style) {
      return style.cssText;
    }).join('\n');
    template.content.appendChild(styleEl);
  }
  /**
   * Returns an array of themes that should be used for styling a component matching
   * the tag name. The array is sorted by the include order.
   * @param {string} tagName
   * @returns {Theme[]}
   */


  function getThemes(tagName) {
    var defaultModuleName = tagName + '-default-theme';
    var themes = getAllThemes() // Filter by matching themeFor properties
    .filter(function (theme) {
      return theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName);
    }).map(function (theme) {
      return _objectSpread(_objectSpread({}, theme), {}, {
        // Prepend styles from included themes
        styles: [].concat(babelHelpers.toConsumableArray(getIncludedStyles(theme)), babelHelpers.toConsumableArray(theme.styles)),
        // Map moduleId to includePriority
        includePriority: getIncludePriority(theme.moduleId)
      });
    }) // Sort by includePriority
    .sort(function (themeA, themeB) {
      return themeB.includePriority - themeA.includePriority;
    });

    if (themes.length > 0) {
      return themes;
    } else {
      // No theme modules found, return the default module if it exists
      return getAllThemes().filter(function (theme) {
        return theme.moduleId === defaultModuleName;
      });
    }
  }
  /**
   * @polymerMixin
   * @mixes ThemePropertyMixin
   */


  var ThemableMixin = function ThemableMixin(superClass) {
    return /*#__PURE__*/function (_ThemePropertyMixin) {
      babelHelpers.inherits(VaadinThemableMixin, _ThemePropertyMixin);

      var _super = _createSuper(VaadinThemableMixin);

      function VaadinThemableMixin() {
        babelHelpers.classCallCheck(this, VaadinThemableMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(VaadinThemableMixin, null, [{
        key: "finalize",
        value:
        /**
         * Covers PolymerElement based component styling
         * @protected
         */
        function finalize() {
          babelHelpers.get(babelHelpers.getPrototypeOf(VaadinThemableMixin), "finalize", this).call(this);
          var template = this.prototype._template;

          if (!template || template.__themes) {
            return;
          }

          var inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;

          var inheritedThemes = (inheritedTemplate ? inheritedTemplate.__themes : []) || [];
          template.__themes = [].concat(babelHelpers.toConsumableArray(inheritedThemes), babelHelpers.toConsumableArray(getThemes(this.is))); // Get flattened styles array

          var styles = template.__themes.reduce(function (styles, theme) {
            return [].concat(babelHelpers.toConsumableArray(styles), babelHelpers.toConsumableArray(theme.styles));
          }, []);

          addStylesToTemplate(styles, template);
        }
        /**
         * Covers LitElement based component styling
         *
         * NOTE: This is not yet an offically supported API!
         *
         * TODO: Add tests (run a variation of themable-mixin.test.js where the components get created as LitElements)
         * @protected
         */

      }, {
        key: "finalizeStyles",
        value: function finalizeStyles(styles) {
          return getThemes(this.is) // Get flattened styles array
          .reduce(function (styles, theme) {
            return [].concat(babelHelpers.toConsumableArray(styles), babelHelpers.toConsumableArray(theme.styles));
          }, []).concat(styles);
        }
      }]);
      return VaadinThemableMixin;
    }((0, _vaadinThemePropertyMixin.ThemePropertyMixin)(superClass));
  };

  _exports.ThemableMixin = ThemableMixin;
});