define(["exports", "../../component-base/src/slot-controller.js"], function (_exports, _slotController) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LabelController = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A controller to manage the label element.
   */
  var LabelController = /*#__PURE__*/function (_SlotController) {
    babelHelpers.inherits(LabelController, _SlotController);

    var _super = _createSuper(LabelController);

    function LabelController(host) {
      var _this;

      babelHelpers.classCallCheck(this, LabelController);
      return _this = _super.call(this, host, 'label', function () {
        return document.createElement('label');
      }, function (_host, node) {
        // Set ID attribute or use the existing one.
        _this.__updateLabelId(node); // Set text content for the default label.


        _this.__updateDefaultLabel(_this.label);

        _this.__observeLabel(node);
      });
    }
    /**
     * @return {string}
     */


    babelHelpers.createClass(LabelController, [{
      key: "labelId",
      get: function get() {
        return this.node.id;
      }
      /**
       * Override to initialize the newly added custom label.
       *
       * @param {Node} labelNode
       * @protected
       * @override
       */

    }, {
      key: "initCustomNode",
      value: function initCustomNode(labelNode) {
        this.__updateLabelId(labelNode);

        var hasLabel = this.__hasLabel(labelNode);

        this.__toggleHasLabel(hasLabel);
      }
      /**
       * Override to cleanup label node when it's removed.
       *
       * @param {Node} node
       * @protected
       * @override
       */

    }, {
      key: "teardownNode",
      value: function teardownNode(node) {
        if (this.__labelObserver) {
          this.__labelObserver.disconnect();
        }

        var labelNode = this.getSlotChild(); // If custom label was removed, restore the default one.

        if (!labelNode && node !== this.defaultNode) {
          labelNode = this.attachDefaultNode(); // Run initializer to update default label and ID.

          this.initNode(labelNode);
        }

        var hasLabel = this.__hasLabel(labelNode);

        this.__toggleHasLabel(hasLabel);
      }
      /**
       * Set label based on corresponding host property.
       *
       * @param {string} label
       */

    }, {
      key: "setLabel",
      value: function setLabel(label) {
        this.label = label;

        this.__updateDefaultLabel(label);
      }
      /**
       * @param {HTMLElement} labelNode
       * @return {boolean}
       * @private
       */

    }, {
      key: "__hasLabel",
      value: function __hasLabel(labelNode) {
        if (!labelNode) {
          return false;
        }

        return labelNode.children.length > 0 || this.__isNotEmpty(labelNode.textContent);
      }
      /**
       * @param {string} label
       * @private
       */

    }, {
      key: "__isNotEmpty",
      value: function __isNotEmpty(label) {
        return Boolean(label && label.trim() !== '');
      }
      /**
       * @param {HTMLElement} labelNode
       * @private
       */

    }, {
      key: "__observeLabel",
      value: function __observeLabel(labelNode) {
        var _this2 = this;

        this.__labelObserver = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            var target = mutation.target; // Ensure the mutation target is the currently connected label
            // to ignore async mutations dispatched for removed element.

            var isLabelMutation = target === _this2.node;

            if (mutation.type === 'attributes') {
              // We use attributeFilter to only observe ID mutation,
              // no need to check for attribute name separately.
              if (isLabelMutation && target.id !== _this2.defaultId) {
                _this2.__updateLabelId(target);
              }
            } else if (isLabelMutation || target.parentElement === _this2.node) {
              // Update has-label when textContent changes
              var hasLabel = _this2.__hasLabel(_this2.node);

              _this2.__toggleHasLabel(hasLabel);
            }
          });
        }); // Observe changes to label ID attribute, text content and children.

        this.__labelObserver.observe(labelNode, {
          attributes: true,
          attributeFilter: ['id'],
          childList: true,
          subtree: true,
          characterData: true
        });
      }
      /**
       * @param {boolean} hasLabel
       * @private
       */

    }, {
      key: "__toggleHasLabel",
      value: function __toggleHasLabel(hasLabel) {
        this.host.toggleAttribute('has-label', hasLabel); // Make it possible for other mixins to observe change

        this.dispatchEvent(new CustomEvent('label-changed', {
          detail: {
            hasLabel: hasLabel,
            node: this.node
          }
        }));
      }
      /**
       * @param {string} label
       * @private
       */

    }, {
      key: "__updateDefaultLabel",
      value: function __updateDefaultLabel(label) {
        if (this.defaultNode) {
          this.defaultNode.textContent = label; // Update has-label if default label is used

          if (this.defaultNode === this.node) {
            var hasLabel = this.__isNotEmpty(label);

            this.__toggleHasLabel(hasLabel);
          }
        }
      }
      /**
       * @param {HTMLElement} labelNode
       * @private
       */

    }, {
      key: "__updateLabelId",
      value: function __updateLabelId(labelNode) {
        if (!labelNode.id) {
          labelNode.id = this.defaultId;
        }
      }
    }]);
    return LabelController;
  }(_slotController.SlotController);

  _exports.LabelController = LabelController;
});