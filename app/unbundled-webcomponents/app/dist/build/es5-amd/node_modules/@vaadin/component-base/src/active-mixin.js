define(["exports", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "./disabled-mixin.js", "./keyboard-mixin.js"], function (_exports, _gestureEventListeners, _disabledMixin, _keyboardMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ActiveMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to toggle the `active` attribute.
   *
   * The attribute is set whenever the user activates the element by a pointer
   * or presses an activation key on the element from the keyboard.
   *
   * The attribute is removed as soon as the element is deactivated
   * by the pointer or by releasing the activation key.
   *
   * @polymerMixin
   */
  var ActiveMixin = function ActiveMixin(superclass) {
    return /*#__PURE__*/function (_DisabledMixin) {
      babelHelpers.inherits(ActiveMixinClass, _DisabledMixin);

      var _super = _createSuper(ActiveMixinClass);

      function ActiveMixinClass() {
        babelHelpers.classCallCheck(this, ActiveMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(ActiveMixinClass, [{
        key: "_activeKeys",
        get:
        /**
         * An array of activation keys.
         *
         * See possible values here:
         * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values
         *
         * @protected
         * @return {!Array<!string>}
         */
        function get() {
          return [' '];
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ActiveMixinClass.prototype), "ready", this).call(this);

          this._addEventListenerToNode(this, 'down', function (event) {
            if (_this._shouldSetActive(event)) {
              _this._setActive(true);
            }
          });

          this._addEventListenerToNode(this, 'up', function () {
            _this._setActive(false);
          });
        }
        /** @protected */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(ActiveMixinClass.prototype), "disconnectedCallback", this).call(this); // When the element is disconnecting from the DOM at the moment being active,
          // the `active` attribute needs to be manually removed from the element.
          // Otherwise, it will preserve on the element until the element is activated once again.
          // The case reproduces for `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

          this._setActive(false);
        }
        /**
         * @param {KeyboardEvent | MouseEvent} _event
         * @protected
         */

      }, {
        key: "_shouldSetActive",
        value: function _shouldSetActive(_event) {
          return !this.disabled;
        }
        /**
         * Sets the `active` attribute on the element if an activation key is pressed.
         *
         * @param {KeyboardEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(ActiveMixinClass.prototype), "_onKeyDown", this).call(this, event);

          if (this._shouldSetActive(event) && this._activeKeys.includes(event.key)) {
            this._setActive(true);
          }
        }
        /**
         * Removes the `active` attribute from the element if the activation key is released.
         *
         * @param {KeyboardEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onKeyUp",
        value: function _onKeyUp(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(ActiveMixinClass.prototype), "_onKeyUp", this).call(this, event);

          if (this._activeKeys.includes(event.key)) {
            this._setActive(false);
          }
        }
        /**
         * Toggles the `active` attribute on the element.
         *
         * @param {boolean} active
         * @protected
         */

      }, {
        key: "_setActive",
        value: function _setActive(active) {
          this.toggleAttribute('active', active);
        }
      }]);
      return ActiveMixinClass;
    }((0, _disabledMixin.DisabledMixin)((0, _gestureEventListeners.GestureEventListeners)((0, _keyboardMixin.KeyboardMixin)(superclass))));
  };

  _exports.ActiveMixin = ActiveMixin;
});