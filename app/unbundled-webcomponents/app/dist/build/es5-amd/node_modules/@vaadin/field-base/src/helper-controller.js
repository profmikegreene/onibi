define(["exports", "../../component-base/src/slot-controller.js"], function (_exports, _slotController) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HelperController = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A controller that manages the helper node content.
   */
  var HelperController = /*#__PURE__*/function (_SlotController) {
    babelHelpers.inherits(HelperController, _SlotController);

    var _super = _createSuper(HelperController);

    function HelperController(host) {
      babelHelpers.classCallCheck(this, HelperController);
      // Do not provide slot factory, as only create helper lazily.
      return _super.call(this, host, 'helper');
    }

    babelHelpers.createClass(HelperController, [{
      key: "helperId",
      get: function get() {
        return this.node && this.node.id;
      }
      /**
       * Override to initialize the newly added custom helper.
       *
       * @param {Node} helperNode
       * @protected
       * @override
       */

    }, {
      key: "initCustomNode",
      value: function initCustomNode(helperNode) {
        this.__updateHelperId(helperNode);

        this.__observeHelper(helperNode);

        var hasHelper = this.__hasHelper(helperNode);

        this.__toggleHasHelper(hasHelper);
      }
      /**
       * Override to cleanup helper node when it's removed.
       *
       * @param {Node} _node
       * @protected
       * @override
       */

    }, {
      key: "teardownNode",
      value: function teardownNode(_node) {
        // The observer does not exist when the default helper is removed.
        if (this.__helperIdObserver) {
          this.__helperIdObserver.disconnect();
        }

        var helperNode = this.getSlotChild(); // Custom node is added to helper slot

        if (helperNode && helperNode !== this.defaultNode) {
          var hasHelper = this.__hasHelper(helperNode);

          this.__toggleHasHelper(hasHelper);
        } else {
          // Restore default helper if needed
          this.__applyDefaultHelper(this.helperText, helperNode);
        }
      }
      /**
       * Set helper text based on corresponding host property.
       * @param {string} helperText
       */

    }, {
      key: "setHelperText",
      value: function setHelperText(helperText) {
        this.helperText = helperText;
        var helperNode = this.getSlotChild();

        if (!helperNode || helperNode === this.defaultNode) {
          this.__applyDefaultHelper(helperText, helperNode);
        }
      }
      /**
       * @param {HTMLElement} helperNode
       * @return {boolean}
       * @private
       */

    }, {
      key: "__hasHelper",
      value: function __hasHelper(helperNode) {
        if (!helperNode) {
          return false;
        }

        return helperNode.children.length > 0 || this.__isNotEmpty(helperNode.textContent);
      }
      /**
       * @param {string} helperText
       * @private
       */

    }, {
      key: "__isNotEmpty",
      value: function __isNotEmpty(helperText) {
        return helperText && helperText.trim() !== '';
      }
      /**
       * @param {string} helperText
       * @param {Node} helperNode
       * @private
       */

    }, {
      key: "__applyDefaultHelper",
      value: function __applyDefaultHelper(helperText, helperNode) {
        var hasHelperText = this.__isNotEmpty(helperText);

        if (hasHelperText && !helperNode) {
          // Set slot factory lazily to only create helper node when needed.
          this.slotFactory = function () {
            return document.createElement('div');
          };

          helperNode = this.attachDefaultNode();

          this.__updateHelperId(helperNode);

          this.__observeHelper(helperNode);
        }

        if (helperNode) {
          helperNode.textContent = helperText;
        }

        this.__toggleHasHelper(hasHelperText);
      }
      /**
       * @param {HTMLElement} helperNode
       * @private
       */

    }, {
      key: "__observeHelper",
      value: function __observeHelper(helperNode) {
        var _this = this;

        this.__helperObserver = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            var target = mutation.target; // Ensure the mutation target is the currently connected helper
            // to ignore async mutations dispatched for removed element.

            var isHelperMutation = target === _this.node;

            if (mutation.type === 'attributes') {
              // We use attributeFilter to only observe ID mutation,
              // no need to check for attribute name separately.
              if (isHelperMutation && target.id !== _this.defaultId) {
                _this.__updateHelperId(target);
              }
            } else if (isHelperMutation || target.parentElement === _this.node) {
              // Update has-helper when textContent changes
              var hasHelper = _this.__hasHelper(_this.node);

              _this.__toggleHasHelper(hasHelper);
            }
          });
        }); // Observe changes to helper ID attribute, text content and children.

        this.__helperObserver.observe(helperNode, {
          attributes: true,
          attributeFilter: ['id'],
          childList: true,
          subtree: true,
          characterData: true
        });
      }
      /**
       * @param {boolean} hasHelper
       * @private
       */

    }, {
      key: "__toggleHasHelper",
      value: function __toggleHasHelper(hasHelper) {
        this.host.toggleAttribute('has-helper', hasHelper); // Make it possible for other mixins to observe change

        this.dispatchEvent(new CustomEvent('helper-changed', {
          detail: {
            hasHelper: hasHelper,
            node: this.node
          }
        }));
      }
      /**
       * @param {HTMLElement} helperNode
       * @private
       */

    }, {
      key: "__updateHelperId",
      value: function __updateHelperId(helperNode) {
        if (!helperNode.id) {
          helperNode.id = this.defaultId;
        }
      }
    }]);
    return HelperController;
  }(_slotController.SlotController);

  _exports.HelperController = HelperController;
});