define(["exports", "../../../@polymer/polymer/lib/utils/mixin.js", "../../component-base/src/focus-mixin.js", "../../component-base/src/tabindex-mixin.js"], function (_exports, _mixin, _focusMixin, _tabindexMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DelegateFocusMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to forward focus to an element in the light DOM.
   *
   * @polymerMixin
   * @mixes FocusMixin
   * @mixes TabindexMixin
   */
  var DelegateFocusMixin = (0, _mixin.dedupingMixin)(function (superclass) {
    return /*#__PURE__*/function (_FocusMixin) {
      babelHelpers.inherits(DelegateFocusMixinClass, _FocusMixin);

      var _super = _createSuper(DelegateFocusMixinClass);

      function DelegateFocusMixinClass() {
        var _this;

        babelHelpers.classCallCheck(this, DelegateFocusMixinClass);
        _this = _super.call(this);
        _this._boundOnBlur = _this._onBlur.bind(babelHelpers.assertThisInitialized(_this));
        _this._boundOnFocus = _this._onFocus.bind(babelHelpers.assertThisInitialized(_this));
        return _this;
      }
      /** @protected */


      babelHelpers.createClass(DelegateFocusMixinClass, [{
        key: "ready",
        value: function ready() {
          var _this2 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(DelegateFocusMixinClass.prototype), "ready", this).call(this);

          if (this.autofocus && !this.disabled) {
            requestAnimationFrame(function () {
              _this2.focus();

              _this2.setAttribute('focus-ring', '');
            });
          }
        }
        /**
         * @protected
         * @override
         */

      }, {
        key: "focus",
        value: function focus() {
          if (!this.focusElement || this.disabled) {
            return;
          }

          this.focusElement.focus();

          this._setFocused(true);
        }
        /**
         * @protected
         * @override
         */

      }, {
        key: "blur",
        value: function blur() {
          if (!this.focusElement) {
            return;
          }

          this.focusElement.blur();

          this._setFocused(false);
        }
        /**
         * @protected
         * @override
         */

      }, {
        key: "click",
        value: function click() {
          if (this.focusElement && !this.disabled) {
            this.focusElement.click();
          }
        }
        /** @protected */

      }, {
        key: "_focusElementChanged",
        value: function _focusElementChanged(element, oldElement) {
          if (element) {
            element.disabled = this.disabled;

            this._addFocusListeners(element);

            this.__forwardTabIndex(this.tabindex);
          } else if (oldElement) {
            this._removeFocusListeners(oldElement);
          }
        }
        /**
         * @param {HTMLElement} element
         * @protected
         */

      }, {
        key: "_addFocusListeners",
        value: function _addFocusListeners(element) {
          element.addEventListener('blur', this._boundOnBlur);
          element.addEventListener('focus', this._boundOnFocus);
        }
        /**
         * @param {HTMLElement} element
         * @protected
         */

      }, {
        key: "_removeFocusListeners",
        value: function _removeFocusListeners(element) {
          element.removeEventListener('blur', this._boundOnBlur);
          element.removeEventListener('focus', this._boundOnFocus);
        }
        /**
         * Focus event does not bubble, so we dispatch it manually
         * on the host element to support adding focus listeners
         * when the focusable element is placed in light DOM.
         * @param {FocusEvent} event
         * @protected
         */

      }, {
        key: "_onFocus",
        value: function _onFocus(event) {
          event.stopPropagation();
          this.dispatchEvent(new Event('focus'));
        }
        /**
         * Blur event does not bubble, so we dispatch it manually
         * on the host element to support adding blur listeners
         * when the focusable element is placed in light DOM.
         * @param {FocusEvent} event
         * @protected
         */

      }, {
        key: "_onBlur",
        value: function _onBlur(event) {
          event.stopPropagation();
          this.dispatchEvent(new Event('blur'));
        }
        /**
         * @param {Event} event
         * @return {boolean}
         * @protected
         * @override
         */

      }, {
        key: "_shouldSetFocus",
        value: function _shouldSetFocus(event) {
          return event.target === this.focusElement;
        }
        /**
         * @param {boolean} disabled
         * @param {boolean} oldDisabled
         * @protected
         * @override
         */

      }, {
        key: "_disabledChanged",
        value: function _disabledChanged(disabled, oldDisabled) {
          babelHelpers.get(babelHelpers.getPrototypeOf(DelegateFocusMixinClass.prototype), "_disabledChanged", this).call(this, disabled, oldDisabled);

          if (this.focusElement) {
            this.focusElement.disabled = disabled;
          }

          if (disabled) {
            this.blur();
          }
        }
        /**
         * Override an observer from `TabindexMixin`.
         * Do not call super to remove tabindex attribute
         * from the host after it has been forwarded.
         * @param {string} tabindex
         * @protected
         * @override
         */

      }, {
        key: "_tabindexChanged",
        value: function _tabindexChanged(tabindex) {
          this.__forwardTabIndex(tabindex);
        }
        /** @private */

      }, {
        key: "__forwardTabIndex",
        value: function __forwardTabIndex(tabindex) {
          if (tabindex !== undefined && this.focusElement) {
            this.focusElement.tabIndex = tabindex; // Preserve tabindex="-1" on the host element

            if (tabindex !== -1) {
              this.tabindex = undefined;
            }
          }

          if (this.disabled && tabindex) {
            // If tabindex attribute was changed while component was disabled
            if (tabindex !== -1) {
              this.__lastTabIndex = tabindex;
            }

            this.tabindex = undefined;
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Specify that this control should have input focus when the page loads.
             */
            autofocus: {
              type: Boolean
            },

            /**
             * A reference to the focusable element controlled by the mixin.
             * It can be an input, textarea, button or any element with tabindex > -1.
             *
             * Any component implementing this mixin is expected to provide it
             * by using `this._setFocusElement(input)` Polymer API.
             *
             * @protected
             * @type {!HTMLElement}
             */
            focusElement: {
              type: Object,
              readOnly: true,
              observer: '_focusElementChanged'
            },

            /**
             * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
             *
             * By default, the host element does not have tabindex attribute. Instead, `focusElement` should have it.
             * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
             *
             * @protected
             */
            tabindex: {
              type: Number,
              value: undefined
            }
          };
        }
      }]);
      return DelegateFocusMixinClass;
    }((0, _focusMixin.FocusMixin)((0, _tabindexMixin.TabindexMixin)(superclass)));
  });
  _exports.DelegateFocusMixin = DelegateFocusMixin;
});