define(["exports", "./input-control-mixin.js"], function (_exports, _inputControlMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.InputFieldMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to provide logic for vaadin-text-field and related components.
   *
   * @polymerMixin
   * @mixes InputControlMixin
   */
  var InputFieldMixin = function InputFieldMixin(superclass) {
    return /*#__PURE__*/function (_InputControlMixin) {
      babelHelpers.inherits(InputFieldMixinClass, _InputControlMixin);

      var _super = _createSuper(InputFieldMixinClass);

      function InputFieldMixinClass() {
        var _this;

        babelHelpers.classCallCheck(this, InputFieldMixinClass);
        _this = _super.call(this);
        _this._boundOnPaste = _this._onPaste.bind(babelHelpers.assertThisInitialized(_this));
        _this._boundOnDrop = _this._onDrop.bind(babelHelpers.assertThisInitialized(_this));
        _this._boundOnBeforeInput = _this._onBeforeInput.bind(babelHelpers.assertThisInitialized(_this));
        return _this;
      }
      /**
       * @param {HTMLElement} input
       * @protected
       * @override
       */


      babelHelpers.createClass(InputFieldMixinClass, [{
        key: "_inputElementChanged",
        value: function _inputElementChanged(input) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_inputElementChanged", this).call(this, input);

          if (input) {
            // Discard value set on the custom slotted input.
            if (input.value && input.value !== this.value) {
              console.warn("Please define value on the <".concat(this.localName, "> component!"));
              input.value = '';
            }

            if (this.value) {
              input.value = this.value;
            }
          }
        } // Workaround for https://github.com/Polymer/polymer/issues/5259

      }, {
        key: "__data",
        get: function get() {
          return this.__dataValue || {};
        },
        set: function set(value) {
          this.__dataValue = value;
        }
        /**
         * Override an event listener from `DelegateFocusMixin`.
         * @param {FocusEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onBlur",
        value: function _onBlur(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_onBlur", this).call(this, event);
          this.validate();
        }
        /**
         * Override an event listener from `InputMixin`
         * to mark as valid after user started typing.
         * @param {Event} event
         * @protected
         * @override
         */

      }, {
        key: "_onInput",
        value: function _onInput(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_onInput", this).call(this, event);

          if (this.invalid) {
            this.validate();
          }
        }
        /**
         * Override a method from `InputMixin` to validate the field
         * when a new value is set programmatically.
         * @param {string} value
         * @protected
         * @override
         */

      }, {
        key: "_forwardInputValue",
        value: function _forwardInputValue(value) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_forwardInputValue", this).call(this, value);

          if (this.invalid) {
            this.validate();
          }
        }
        /**
         * Override a method from `InputMixin`.
         * @param {!HTMLElement} input
         * @protected
         * @override
         */

      }, {
        key: "_addInputListeners",
        value: function _addInputListeners(input) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_addInputListeners", this).call(this, input);
          input.addEventListener('paste', this._boundOnPaste);
          input.addEventListener('drop', this._boundOnDrop);
          input.addEventListener('beforeinput', this._boundOnBeforeInput);
        }
        /**
         * Override a method from `InputMixin`.
         * @param {!HTMLElement} input
         * @protected
         * @override
         */

      }, {
        key: "_removeInputListeners",
        value: function _removeInputListeners(input) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_removeInputListeners", this).call(this, input);
          input.removeEventListener('paste', this._boundOnPaste);
          input.removeEventListener('drop', this._boundOnDrop);
          input.removeEventListener('beforeinput', this._boundOnBeforeInput);
        }
        /**
         * Override an event listener from `ClearButtonMixin`
         * to avoid adding a separate listener.
         * @param {!KeyboardEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
          if (this._enabledCharPattern && !this.__shouldAcceptKey(event)) {
            event.preventDefault();
          }

          babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass.prototype), "_onKeyDown", this).call(this, event);
        }
        /** @private */

      }, {
        key: "__shouldAcceptKey",
        value: function __shouldAcceptKey(event) {
          return event.metaKey || event.ctrlKey || !event.key || // allow typing anything if event.key is not supported
          event.key.length !== 1 || // allow "Backspace", "ArrowLeft" etc.
          this.__enabledCharRegExp.test(event.key);
        }
        /** @private */

      }, {
        key: "_onPaste",
        value: function _onPaste(e) {
          if (this._enabledCharPattern) {
            var pastedText = (e.clipboardData || window.clipboardData).getData('text');

            if (!this.__enabledTextRegExp.test(pastedText)) {
              e.preventDefault();
            }
          }
        }
        /** @private */

      }, {
        key: "_onDrop",
        value: function _onDrop(e) {
          if (this._enabledCharPattern) {
            var draggedText = e.dataTransfer.getData('text');

            if (!this.__enabledTextRegExp.test(draggedText)) {
              e.preventDefault();
            }
          }
        }
        /** @private */

      }, {
        key: "_onBeforeInput",
        value: function _onBeforeInput(e) {
          // The `beforeinput` event covers all the cases for `_enabledCharPattern`: keyboard, pasting and dropping,
          // but it is still experimental technology so we can't rely on it. It's used here just as an additional check,
          // because it seems to be the only way to detect and prevent specific keys on mobile devices.
          // See https://github.com/vaadin/vaadin-text-field/issues/429
          if (this._enabledCharPattern && e.data && !this.__enabledTextRegExp.test(e.data)) {
            e.preventDefault();
          }
        }
        /** @private */

      }, {
        key: "_enabledCharPatternChanged",
        value: function _enabledCharPatternChanged(charPattern) {
          if (charPattern) {
            this.__enabledCharRegExp = new RegExp('^' + charPattern + '$');
            this.__enabledTextRegExp = new RegExp('^' + charPattern + '*$');
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Whether the value of the control can be automatically completed by the browser.
             * List of available options at:
             * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
             */
            autocomplete: {
              type: String
            },

            /**
             * This is a property supported by Safari that is used to control whether
             * autocorrection should be enabled when the user is entering/editing the text.
             * Possible values are:
             * on: Enable autocorrection.
             * off: Disable autocorrection.
             */
            autocorrect: {
              type: String
            },

            /**
             * This is a property supported by Safari and Chrome that is used to control whether
             * autocapitalization should be enabled when the user is entering/editing the text.
             * Possible values are:
             * characters: Characters capitalization.
             * words: Words capitalization.
             * sentences: Sentences capitalization.
             * none: No capitalization.
             */
            autocapitalize: {
              type: String
            },

            /**
             * A pattern matched against individual characters the user inputs.
             * When set, the field will prevent:
             * - `keyDown` events if the entered key doesn't match `/^_enabledCharPattern$/`
             * - `paste` events if the pasted text doesn't match `/^_enabledCharPattern*$/`
             * - `drop` events if the dropped text doesn't match `/^_enabledCharPattern*$/`
             *
             * For example, to enable entering only numbers and minus signs,
             * `_enabledCharPattern = "[\\d-]"`
             * @protected
             */
            _enabledCharPattern: {
              type: String,
              observer: '_enabledCharPatternChanged'
            }
          };
        }
      }, {
        key: "delegateAttrs",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(InputFieldMixinClass), "delegateAttrs", this)), ['autocapitalize', 'autocomplete', 'autocorrect']);
        }
      }]);
      return InputFieldMixinClass;
    }((0, _inputControlMixin.InputControlMixin)(superclass));
  };

  _exports.InputFieldMixin = InputFieldMixin;
});