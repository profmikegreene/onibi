define(["exports", "../../../@polymer/polymer/lib/utils/mixin.js"], function (_exports, _mixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.InputMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to store the reference to an input element
   * and add input and change event listeners to it.
   *
   * @polymerMixin
   */
  var InputMixin = (0, _mixin.dedupingMixin)(function (superclass) {
    return /*#__PURE__*/function (_superclass) {
      babelHelpers.inherits(InputMixinClass, _superclass);

      var _super = _createSuper(InputMixinClass);

      function InputMixinClass() {
        var _this;

        babelHelpers.classCallCheck(this, InputMixinClass);
        _this = _super.call(this);
        _this._boundOnInput = _this._onInput.bind(babelHelpers.assertThisInitialized(_this));
        _this._boundOnChange = _this._onChange.bind(babelHelpers.assertThisInitialized(_this));
        return _this;
      }
      /**
       * Clear the value of the field.
       */


      babelHelpers.createClass(InputMixinClass, [{
        key: "clear",
        value: function clear() {
          this.value = '';
        }
        /**
         * Add event listeners to the input element instance.
         * Override this method to add custom listeners.
         * @param {!HTMLElement} input
         */

      }, {
        key: "_addInputListeners",
        value: function _addInputListeners(input) {
          input.addEventListener('input', this._boundOnInput);
          input.addEventListener('change', this._boundOnChange);
        }
        /**
         * Remove event listeners from the input element instance.
         * @param {!HTMLElement} input
         */

      }, {
        key: "_removeInputListeners",
        value: function _removeInputListeners(input) {
          input.removeEventListener('input', this._boundOnInput);
          input.removeEventListener('change', this._boundOnChange);
        }
        /**
         * A method to forward the value property set on the field
         * programmatically back to the input element value.
         * Override this method to perform additional checks,
         * for example to skip this in certain conditions.
         * @param {string} value
         * @protected
         * @override
         */

      }, {
        key: "_forwardInputValue",
        value: function _forwardInputValue(value) {
          // Value might be set before an input element is initialized.
          // This case should be handled separately by a component that
          // implements this mixin, for example in `connectedCallback`.
          if (!this.inputElement) {
            return;
          }

          if (value != undefined) {
            this.inputElement.value = value;
          } else {
            this.inputElement.value = '';
          }
        }
        /** @protected */

      }, {
        key: "_inputElementChanged",
        value: function _inputElementChanged(input, oldInput) {
          if (input) {
            this._addInputListeners(input);
          } else if (oldInput) {
            this._removeInputListeners(oldInput);
          }
        }
        /**
         * An input event listener used to update the field value.
         * Override this method with an actual implementation.
         * @param {Event} _event
         * @protected
         * @override
         */

      }, {
        key: "_onInput",
        value: function _onInput(event) {
          // Ignore fake input events e.g. used by clear button.
          this.__userInput = event.isTrusted;
          this.value = event.target.value;
          this.__userInput = false;
        }
        /**
         * A change event listener.
         * Override this method with an actual implementation.
         * @param {Event} _event
         * @protected
         * @override
         */

      }, {
        key: "_onChange",
        value: function _onChange(_event) {}
        /**
         * Toggle the has-value attribute based on the value property.
         * @param {boolean} hasValue
         * @protected
         */

      }, {
        key: "_toggleHasValue",
        value: function _toggleHasValue(hasValue) {
          this.toggleAttribute('has-value', hasValue);
        }
        /**
         * Observer called when a value property changes.
         * @param {string | undefined} newVal
         * @param {string | undefined} oldVal
         * @protected
         * @override
         */

      }, {
        key: "_valueChanged",
        value: function _valueChanged(newVal, oldVal) {
          this._toggleHasValue(newVal !== '' && newVal != null); // Setting initial value to empty string, do nothing.


          if (newVal === '' && oldVal === undefined) {
            return;
          } // Value is set by the user, no need to sync it back to input.


          if (this.__userInput) {
            return;
          } // Setting a value programmatically, sync it to input element.


          this._forwardInputValue(newVal);
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * A reference to the input element controlled by the mixin.
             * Any component implementing this mixin is expected to provide it
             * by using `this._setInputElement(input)` Polymer API.
             *
             * A typical case is using `InputController` that does this automatically.
             * However, the input element does not have to always be native <input>:
             * as an example, <vaadin-combo-box-light> accepts other components.
             *
             * @protected
             * @type {!HTMLElement}
             */
            inputElement: {
              type: Object,
              readOnly: true,
              observer: '_inputElementChanged'
            },

            /**
             * String used to define input type.
             * @protected
             */
            type: {
              type: String,
              readOnly: true
            },

            /**
             * The value of the field.
             */
            value: {
              type: String,
              value: '',
              observer: '_valueChanged',
              notify: true
            }
          };
        }
      }]);
      return InputMixinClass;
    }(superclass);
  });
  _exports.InputMixin = InputMixin;
});