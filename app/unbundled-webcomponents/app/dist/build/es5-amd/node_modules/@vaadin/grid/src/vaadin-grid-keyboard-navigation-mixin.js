define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.KeyboardNavigationMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @license
   * Copyright (c) 2016 - 2022 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   */

  /**
   * @polymerMixin
   */
  var KeyboardNavigationMixin = function KeyboardNavigationMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(KeyboardNavigationMixin, _superClass);

      var _super = _createSuper(KeyboardNavigationMixin);

      function KeyboardNavigationMixin() {
        babelHelpers.classCallCheck(this, KeyboardNavigationMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(KeyboardNavigationMixin, [{
        key: "ready",
        value:
        /** @protected */
        function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(KeyboardNavigationMixin.prototype), "ready", this).call(this);

          if (this._ios || this._android) {
            // Disable keyboard navigation on mobile devices
            return;
          }

          this.addEventListener('keydown', this._onKeyDown);
          this.addEventListener('keyup', this._onKeyUp);
          this.addEventListener('focusin', this._onFocusIn);
          this.addEventListener('focusout', this._onFocusOut); // When focus goes from cell to another cell, focusin/focusout events do
          // not escape the grid’s shadowRoot, thus listening inside the shadowRoot.

          this.$.table.addEventListener('focusin', this._onContentFocusIn.bind(this));
          this.addEventListener('mousedown', function () {
            _this.toggleAttribute('navigating', false);

            _this._isMousedown = true;
          });
          this.addEventListener('mouseup', function () {
            return _this._isMousedown = false;
          });
        }
        /** @private */

      }, {
        key: "__rowFocusMode",
        get: function get() {
          return this.__isRow(this._itemsFocusable) || this.__isRow(this._headerFocusable) || this.__isRow(this._footerFocusable);
        },
        set: function set(value) {
          var _this2 = this;

          ['_itemsFocusable', '_footerFocusable', '_headerFocusable'].forEach(function (focusable) {
            if (value && _this2.__isCell(_this2[focusable])) {
              _this2[focusable] = _this2[focusable].parentElement;
            } else if (!value && _this2.__isRow(_this2[focusable])) {
              _this2[focusable] = _this2[focusable].firstElementChild;
            }
          });
        }
        /** @private */

      }, {
        key: "_focusableChanged",
        value: function _focusableChanged(focusable, oldFocusable) {
          if (oldFocusable) {
            oldFocusable.setAttribute('tabindex', '-1');
          }

          if (focusable) {
            this._updateGridSectionFocusTarget(focusable);
          }
        }
        /** @private */

      }, {
        key: "_interactingChanged",
        value: function _interactingChanged() {
          // Update focus targets when entering / exiting interaction mode
          this._updateGridSectionFocusTarget(this._headerFocusable);

          this._updateGridSectionFocusTarget(this._itemsFocusable);

          this._updateGridSectionFocusTarget(this._footerFocusable);
        }
        /**
         * Since the focused cell/row state is stored as an element reference, the reference may get
         * out of sync when the virtual indexes for elements update due to effective size change.
         * This function updates the reference to the correct element after a possible index change.
         * @private
         */

      }, {
        key: "__updateItemsFocusable",
        value: function __updateItemsFocusable() {
          var _this3 = this;

          if (!this._itemsFocusable) {
            return;
          }

          var wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;

          this._getVisibleRows().forEach(function (row) {
            if (row.index === _this3._focusedItemIndex) {
              if (_this3.__rowFocusMode) {
                // Row focus mode
                _this3._itemsFocusable = row;
              } else if (_this3._itemsFocusable.parentElement) {
                // Cell focus mode
                var cellIndex = babelHelpers.toConsumableArray(_this3._itemsFocusable.parentElement.children).indexOf(_this3._itemsFocusable);
                _this3._itemsFocusable = row.children[cellIndex];
              }
            }
          });

          if (wasFocused) {
            this._itemsFocusable.focus();
          }
        }
        /**
         * @param {!KeyboardEvent} e
         * @protected
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(e) {
          var key = e.key;
          var keyGroup;

          switch (key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'PageUp':
            case 'PageDown':
            case 'Home':
            case 'End':
              keyGroup = 'Navigation';
              break;

            case 'Enter':
            case 'Escape':
            case 'F2':
              keyGroup = 'Interaction';
              break;

            case 'Tab':
              keyGroup = 'Tab';
              break;

            case ' ':
              keyGroup = 'Space';
              break;
          }

          this._detectInteracting(e);

          if (this.interacting && keyGroup !== 'Interaction') {
            // When in the interacting mode, only the “Interaction” keys are handled.
            keyGroup = undefined;
          }

          if (keyGroup) {
            this["_on".concat(keyGroup, "KeyDown")](e, key);
          }
        }
        /** @private */

      }, {
        key: "_ensureScrolledToIndex",
        value: function _ensureScrolledToIndex(index) {
          var targetRowInDom = babelHelpers.toConsumableArray(this.$.items.children).find(function (child) {
            return child.index === index;
          });

          if (!targetRowInDom) {
            this.scrollToIndex(index);
          } else {
            this.__scrollIntoViewport(index);
          }
        } // TODO: A tree toggle component should not be the way to determine if the row is expandable

        /** @private */

      }, {
        key: "__isRowExpandable",
        value: function __isRowExpandable(row) {
          var treeToggle = babelHelpers.toConsumableArray(row.children).reduce(function (value, cell) {
            return value || cell._content.querySelector('vaadin-grid-tree-toggle');
          }, null);
          return treeToggle && !treeToggle.expanded && !treeToggle.leaf;
        }
        /** @private */

      }, {
        key: "__isRowCollapsible",
        value: function __isRowCollapsible(row) {
          return this._isExpanded(row._item);
        }
        /** @private */

      }, {
        key: "__isDetailsCell",
        value: function __isDetailsCell(element) {
          return element.matches('[part~="details-cell"]');
        }
        /** @private */

      }, {
        key: "__isCell",
        value: function __isCell(element) {
          return babelHelpers.instanceof(element, HTMLTableCellElement);
        }
        /** @private */

      }, {
        key: "__isRow",
        value: function __isRow(element) {
          return babelHelpers.instanceof(element, HTMLTableRowElement);
        }
        /** @private */

      }, {
        key: "__getIndexOfChildElement",
        value: function __getIndexOfChildElement(el) {
          return Array.prototype.indexOf.call(el.parentNode.children, el);
        }
        /** @private */

      }, {
        key: "_onNavigationKeyDown",
        value: function _onNavigationKeyDown(e, key) {
          var _this4 = this;

          e.preventDefault();
          var visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1; // Handle keyboard interaction as defined in:
          // https://w3c.github.io/aria-practices/#keyboard-interaction-24

          var dx = 0,
              dy = 0;

          switch (key) {
            case 'ArrowRight':
              dx = this.__isRTL ? -1 : 1;
              break;

            case 'ArrowLeft':
              dx = this.__isRTL ? 1 : -1;
              break;

            case 'Home':
              if (this.__rowFocusMode) {
                // "If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move."
                dy = -Infinity;
              } else {
                if (e.ctrlKey) {
                  // "If focus is on a cell, moves focus to the first cell in the column. If focus is in the first row, focus does not move."
                  dy = -Infinity;
                } else {
                  // "If focus is on a cell, moves focus to the first cell in the row. If focus is in the first cell of the row, focus does not move."
                  dx = -Infinity;
                }
              }

              break;

            case 'End':
              if (this.__rowFocusMode) {
                // "If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move."
                dy = Infinity;
              } else {
                if (e.ctrlKey) {
                  // "If focus is on a cell, moves focus to the last cell in the column. If focus is in the last row, focus does not move."
                  dy = Infinity;
                } else {
                  // "If focus is on a cell, moves focus to the last cell in the row. If focus is in the last cell of the row, focus does not move."
                  dx = Infinity;
                }
              }

              break;

            case 'ArrowDown':
              dy = 1;
              break;

            case 'ArrowUp':
              dy = -1;
              break;

            case 'PageDown':
              dy = visibleItemsCount;
              break;

            case 'PageUp':
              dy = -visibleItemsCount;
              break;
          }

          var activeRow = e.composedPath().find(function (el) {
            return _this4.__isRow(el);
          });
          var activeCell = e.composedPath().find(function (el) {
            return _this4.__isCell(el);
          });

          if (this.__rowFocusMode && !activeRow || !this.__rowFocusMode && !activeCell) {
            // When using a screen reader, it's possible that neither a cell nor a row is focused.
            return;
          }

          var forwardsKey = this.__isRTL ? 'ArrowLeft' : 'ArrowRight';
          var backwardsKey = this.__isRTL ? 'ArrowRight' : 'ArrowLeft';

          if (key === forwardsKey) {
            // "Right Arrow:"
            if (this.__rowFocusMode) {
              // In row focus mode
              if (this.__isRowExpandable(activeRow)) {
                // "If focus is on a collapsed row, expands the row."
                this.expandItem(activeRow._item);
                return;
              } else {
                // "If focus is on an expanded row or is on a row that does not have child rows,
                // moves focus to the first cell in the row."
                this.__rowFocusMode = false;

                this._onCellNavigation(activeRow.firstElementChild, 0, 0);

                return;
              }
            }
          } else if (key === backwardsKey) {
            // "Left Arrow:"
            if (this.__rowFocusMode) {
              // In row focus mode
              if (this.__isRowCollapsible(activeRow)) {
                // "If focus is on an expanded row, collapses the row."
                this.collapseItem(activeRow._item);
                return;
              }
            } else {
              // In cell focus mode
              var activeRowCells = babelHelpers.toConsumableArray(activeRow.children).sort(function (a, b) {
                return a._order - b._order;
              });

              if (activeCell === activeRowCells[0] || this.__isDetailsCell(activeCell)) {
                // "If focus is on the first cell in a row and row focus is supported, moves focus to the row."
                this.__rowFocusMode = true;

                this._onRowNavigation(activeRow, 0);

                return;
              }
            }
          } // Navigate


          if (this.__rowFocusMode) {
            // Navigate the rows
            this._onRowNavigation(activeRow, dy);
          } else {
            // Navigate the cells
            this._onCellNavigation(activeCell, dx, dy);
          }
        }
        /**
         * Focuses the target row after navigating by the given dy offset.
         * If the row is not in the viewport, it is first scrolled to.
         * @private
         **/

      }, {
        key: "_onRowNavigation",
        value: function _onRowNavigation(activeRow, dy) {
          var _this$__navigateRows = this.__navigateRows(dy, activeRow),
              dstRow = _this$__navigateRows.dstRow;

          if (dstRow) {
            dstRow.focus();
          }
        }
        /** @private */

      }, {
        key: "__getIndexInGroup",
        value: function __getIndexInGroup(row, bodyFallbackIndex) {
          var rowGroup = row.parentNode; // Body rows have index property, otherwise DOM child index of the row is used.

          if (rowGroup === this.$.items) {
            return bodyFallbackIndex !== undefined ? bodyFallbackIndex : row.index;
          } else {
            return this.__getIndexOfChildElement(row);
          }
        }
        /**
         * Returns the target row after navigating by the given dy offset.
         * Also returns infromation whether the details cell should be the target on the target row.
         * If the row is not in the viewport, it is first scrolled to.
         * @private
         **/

      }, {
        key: "__navigateRows",
        value: function __navigateRows(dy, activeRow, activeCell) {
          var currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);

          var activeRowGroup = activeRow.parentNode;
          var maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1; // Index of the destination row

          var dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));

          if (activeRowGroup !== this.$.items) {
            // Navigating header/footer rows
            // Header and footer could have hidden rows, e. g., if none of the columns
            // or groups on the given column tree level define template. Skip them
            // in vertical keyboard navigation.
            if (dstRowIndex > currentRowIndex) {
              while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
                dstRowIndex++;
              }
            } else if (dstRowIndex < currentRowIndex) {
              while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
                dstRowIndex--;
              }
            }

            this.toggleAttribute('navigating', true);
            return {
              dstRow: activeRowGroup.children[dstRowIndex]
            };
          } else {
            // Navigating body rows
            var dstIsRowDetails = false;

            if (activeCell) {
              var isRowDetails = this.__isDetailsCell(activeCell); // Row details navigation logic


              if (activeRowGroup === this.$.items) {
                var item = activeRow._item;

                var dstItem = this._cache.getItemForIndex(dstRowIndex); // Should we navigate to row details?


                if (isRowDetails) {
                  dstIsRowDetails = dy === 0;
                } else {
                  dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem);
                } // Should we navigate between details and regular cells of the same row?


                if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
                  dstRowIndex = currentRowIndex;
                }
              }
            } // Ensure correct vertical scroll position, destination row is visible


            this._ensureScrolledToIndex(dstRowIndex); // When scrolling with repeated keydown, sometimes FocusEvent listeners
            // are too late to update _focusedItemIndex. Ensure next keydown
            // listener invocation gets updated _focusedItemIndex value.


            this._focusedItemIndex = dstRowIndex; // This has to be set after scrolling, otherwise it can be removed by
            // `_preventScrollerRotatingCellFocus(row, index)` during scrolling.

            this.toggleAttribute('navigating', true);
            return {
              dstRow: babelHelpers.toConsumableArray(activeRowGroup.children).find(function (el) {
                return !el.hidden && el.index === dstRowIndex;
              }),
              dstIsRowDetails: dstIsRowDetails
            };
          }
        }
        /**
         * Focuses the target cell after navigating by the given dx and dy offset.
         * If the cell is not in the viewport, it is first scrolled to.
         * @private
         **/

      }, {
        key: "_onCellNavigation",
        value: function _onCellNavigation(activeCell, dx, dy) {
          var _this5 = this;

          var activeRow = activeCell.parentNode;

          var _this$__navigateRows2 = this.__navigateRows(dy, activeRow, activeCell),
              dstRow = _this$__navigateRows2.dstRow,
              dstIsRowDetails = _this$__navigateRows2.dstIsRowDetails;

          if (!dstRow) {
            return;
          }

          var columnIndex = this.__getIndexOfChildElement(activeCell);

          var isCurrentCellRowDetails = this.__isDetailsCell(activeCell);

          var activeRowGroup = activeRow.parentNode;

          var currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex); // _focusedColumnOrder is memoized — this is to ensure predictable
          // navigation when entering and leaving detail and column group cells.


          if (this._focusedColumnOrder === undefined) {
            if (isCurrentCellRowDetails) {
              this._focusedColumnOrder = 0;
            } else {
              this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter(function (c) {
                return !c.hidden;
              })[columnIndex]._order;
            }
          }

          if (dstIsRowDetails) {
            // Focusing a row details cell on the destination row
            var dstCell = babelHelpers.toConsumableArray(dstRow.children).find(function (el) {
              return _this5.__isDetailsCell(el);
            });
            dstCell.focus();
          } else {
            // Focusing a regular cell on the destination row
            // Find orderedColumnIndex — the index of order closest matching the
            // original _focusedColumnOrder in the sorted array of orders
            // of the visible columns on the destination row.
            var dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);

            var dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter(function (c) {
              return !c.hidden;
            });

            var dstSortedColumnOrders = dstColumns.map(function (c) {
              return c._order;
            }).sort(function (b, a) {
              return b - a;
            });
            var maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
            var orderedColumnIndex = dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort(function (b, a) {
              return Math.abs(b - _this5._focusedColumnOrder) - Math.abs(a - _this5._focusedColumnOrder);
            })[0]); // Index of the destination column order

            var dstOrderedColumnIndex = dy === 0 && isCurrentCellRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));

            if (dstOrderedColumnIndex !== orderedColumnIndex) {
              // Horizontal movement invalidates stored _focusedColumnOrder
              this._focusedColumnOrder = undefined;
            }

            var columnIndexByOrder = dstColumns.reduce(function (acc, col, i) {
              return acc[col._order] = i, acc;
            }, {});
            var dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];
            var _dstCell = dstRow.children[dstColumnIndex];

            this._scrollHorizontallyToCell(_dstCell);

            _dstCell.focus();
          }
        }
        /** @private */

      }, {
        key: "_onInteractionKeyDown",
        value: function _onInteractionKeyDown(e, key) {
          var _this6 = this;

          var localTarget = e.composedPath()[0];
          var localTargetIsTextInput = localTarget.localName === 'input' && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);
          var wantInteracting;

          switch (key) {
            case 'Enter':
              wantInteracting = this.interacting ? !localTargetIsTextInput : true;
              break;

            case 'Escape':
              wantInteracting = false;
              break;

            case 'F2':
              wantInteracting = !this.interacting;
              break;
          }

          var _this$_getGridEventLo = this._getGridEventLocation(e),
              cell = _this$_getGridEventLo.cell;

          if (this.interacting !== wantInteracting && cell !== null) {
            if (wantInteracting) {
              var focusTarget = cell._content.querySelector('[focus-target]') || // If a child element hasn't been explicitly marked as a focus target,
              // fall back to any focusable element inside the cell.
              babelHelpers.toConsumableArray(cell._content.querySelectorAll('*')).find(function (node) {
                return _this6._isFocusable(node);
              });

              if (focusTarget) {
                e.preventDefault();
                focusTarget.focus();

                this._setInteracting(true);

                this.toggleAttribute('navigating', false);
              }
            } else {
              e.preventDefault();
              this._focusedColumnOrder = undefined;
              cell.focus();

              this._setInteracting(false);

              this.toggleAttribute('navigating', true);
            }
          }
        }
        /** @private */

      }, {
        key: "_predictFocusStepTarget",
        value: function _predictFocusStepTarget(srcElement, step) {
          var tabOrder = [this.$.table, this._headerFocusable, this._itemsFocusable, this._footerFocusable, this.$.focusexit];
          var index = tabOrder.indexOf(srcElement);
          index += step;

          while (index >= 0 && index <= tabOrder.length - 1) {
            var rowElement = tabOrder[index];

            if (rowElement && !this.__rowFocusMode) {
              rowElement = tabOrder[index].parentNode;
            }

            if (!rowElement || rowElement.hidden) {
              index += step;
            } else {
              break;
            }
          }

          return tabOrder[index];
        }
        /** @private */

      }, {
        key: "_onTabKeyDown",
        value: function _onTabKeyDown(e) {
          var _this7 = this;

          var focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);

          if (focusTarget === this.$.table) {
            // The focus is about to exit the grid to the top.
            this.$.table.focus();
          } else if (focusTarget === this.$.focusexit) {
            // The focus is about to exit the grid to the bottom.
            this.$.focusexit.focus();
          } else if (focusTarget === this._itemsFocusable) {
            var itemsFocusTarget = focusTarget;
            var targetRow = this.__isRow(focusTarget) ? focusTarget : focusTarget.parentNode;

            this._ensureScrolledToIndex(this._focusedItemIndex);

            if (targetRow.index !== this._focusedItemIndex && this.__isCell(focusTarget)) {
              // The target row, which is about to be focused next, has been
              // assigned with a new index since last focus, probably because of
              // scrolling. Focus the row for the stored focused item index instead.
              var columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);
              var focusedItemRow = Array.from(this.$.items.children).find(function (row) {
                return !row.hidden && row.index === _this7._focusedItemIndex;
              });

              if (focusedItemRow) {
                itemsFocusTarget = focusedItemRow.children[columnIndex];
              }
            }

            e.preventDefault();
            itemsFocusTarget.focus();
          } else {
            e.preventDefault();
            focusTarget.focus();
          }

          this.toggleAttribute('navigating', true);
        }
        /** @private */

      }, {
        key: "_onSpaceKeyDown",
        value: function _onSpaceKeyDown(e) {
          e.preventDefault();
          var element = e.composedPath()[0];

          var isRow = this.__isRow(element);

          if (isRow || !element._content || !element._content.firstElementChild) {
            this.dispatchEvent(new CustomEvent(isRow ? 'row-activate' : 'cell-activate', {
              detail: {
                model: this.__getRowModel(isRow ? element : element.parentElement)
              }
            }));
          }
        }
        /** @private */

      }, {
        key: "_onKeyUp",
        value: function _onKeyUp(e) {
          if (!/^( |SpaceBar)$/.test(e.key) || this.interacting) {
            return;
          }

          e.preventDefault();
          var cell = e.composedPath()[0];

          if (cell._content && cell._content.firstElementChild) {
            var wasNavigating = this.hasAttribute('navigating');

            cell._content.firstElementChild.click();

            this.toggleAttribute('navigating', wasNavigating);
          }
        }
        /**
         * @param {!FocusEvent} e
         * @protected
         */

      }, {
        key: "_onFocusIn",
        value: function _onFocusIn(e) {
          if (!this._isMousedown) {
            this.toggleAttribute('navigating', true);
          }

          var rootTarget = e.composedPath()[0];

          if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
            // The focus enters the top (bottom) of the grid, meaning that user has
            // tabbed (shift-tabbed) into the grid. Move the focus to
            // the first (the last) focusable.
            this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();

            this._setInteracting(false);
          } else {
            this._detectInteracting(e);
          }
        }
        /**
         * @param {!FocusEvent} e
         * @protected
         */

      }, {
        key: "_onFocusOut",
        value: function _onFocusOut(e) {
          this.toggleAttribute('navigating', false);

          this._detectInteracting(e);
        }
        /** @private */

      }, {
        key: "_onContentFocusIn",
        value: function _onContentFocusIn(e) {
          var _this$_getGridEventLo2 = this._getGridEventLocation(e),
              section = _this$_getGridEventLo2.section,
              cell = _this$_getGridEventLo2.cell,
              row = _this$_getGridEventLo2.row;

          this._detectInteracting(e);

          if (section && (cell || row)) {
            this._activeRowGroup = section;

            if (this.$.header === section) {
              this._headerFocusable = this.__rowFocusMode ? row : cell;
            } else if (this.$.items === section) {
              this._itemsFocusable = this.__rowFocusMode ? row : cell;
            } else if (this.$.footer === section) {
              this._footerFocusable = this.__rowFocusMode ? row : cell;
            }

            if (cell) {
              // Fire a public event for cell.
              var context = this.getEventContext(e);
              cell.dispatchEvent(new CustomEvent('cell-focus', {
                bubbles: true,
                composed: true,
                detail: {
                  context: context
                }
              }));
            }
          }

          this._detectFocusedItemIndex(e);
        }
        /** @private
         * Enables interaction mode if a cells descendant receives focus or keyboard
         * input. Disables it if the event is not related to cell content.
         * @param {!KeyboardEvent|!FocusEvent} e
         */

      }, {
        key: "_detectInteracting",
        value: function _detectInteracting(e) {
          var isInteracting = e.composedPath().some(function (el) {
            return el.localName === 'vaadin-grid-cell-content';
          });

          this._setInteracting(isInteracting);
        }
        /** @private */

      }, {
        key: "_detectFocusedItemIndex",
        value: function _detectFocusedItemIndex(e) {
          var _this$_getGridEventLo3 = this._getGridEventLocation(e),
              section = _this$_getGridEventLo3.section,
              row = _this$_getGridEventLo3.row;

          if (section === this.$.items) {
            this._focusedItemIndex = row.index;
          }
        }
        /** @private
         * Enables or disables the focus target of the containing section of the
         * grid from receiving focus, based on whether the user is interacting with
         * that section of the grid.
         * @param {HTMLElement} focusTarget
         */

      }, {
        key: "_updateGridSectionFocusTarget",
        value: function _updateGridSectionFocusTarget(focusTarget) {
          if (!focusTarget) return;

          var section = this._getGridSectionFromFocusTarget(focusTarget);

          var isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;
          focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;
        }
        /**
         * @param {!HTMLTableRowElement} row
         * @param {number} index
         * @protected
         */

      }, {
        key: "_preventScrollerRotatingCellFocus",
        value: function _preventScrollerRotatingCellFocus(row, index) {
          if (row.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {
            // Focused item has went, hide navigation mode
            this._navigatingIsHidden = true;
            this.toggleAttribute('navigating', false);
          }

          if (index === this._focusedItemIndex && this._navigatingIsHidden) {
            // Focused item is back, restore navigation mode
            this._navigatingIsHidden = false;
            this.toggleAttribute('navigating', true);
          }
        }
        /**
         * @param {HTMLTableSectionElement=} rowGroup
         * @param {number=} rowIndex
         * @return {!Array<!GridColumn>}
         * @protected
         */

      }, {
        key: "_getColumns",
        value: function _getColumns(rowGroup, rowIndex) {
          var columnTreeLevel = this._columnTree.length - 1;

          if (rowGroup === this.$.header) {
            columnTreeLevel = rowIndex;
          } else if (rowGroup === this.$.footer) {
            columnTreeLevel = this._columnTree.length - 1 - rowIndex;
          }

          return this._columnTree[columnTreeLevel];
        }
        /** @private */

      }, {
        key: "__isValidFocusable",
        value: function __isValidFocusable(element) {
          return this.$.table.contains(element) && element.offsetHeight;
        }
        /** @protected */

      }, {
        key: "_resetKeyboardNavigation",
        value: function _resetKeyboardNavigation() {
          var _this8 = this;

          // Header / footer
          ['header', 'footer'].forEach(function (section) {
            if (!_this8.__isValidFocusable(_this8["_".concat(section, "Focusable")])) {
              var firstVisibleRow = babelHelpers.toConsumableArray(_this8.$[section].children).find(function (row) {
                return row.offsetHeight;
              });
              var firstVisibleCell = firstVisibleRow ? babelHelpers.toConsumableArray(firstVisibleRow.children).find(function (cell) {
                return !cell.hidden;
              }) : null;

              if (firstVisibleRow && firstVisibleCell) {
                _this8["_".concat(section, "Focusable")] = _this8.__rowFocusMode ? firstVisibleRow : firstVisibleCell;
              }
            }
          }); // Body

          if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
            var firstVisibleRow = this.__getFirstVisibleItem();

            var firstVisibleCell = firstVisibleRow ? babelHelpers.toConsumableArray(firstVisibleRow.children).find(function (cell) {
              return !cell.hidden;
            }) : null;

            if (firstVisibleCell && firstVisibleRow) {
              // Reset memoized column
              delete this._focusedColumnOrder;
              this._itemsFocusable = this.__rowFocusMode ? firstVisibleRow : firstVisibleCell;
            }
          } else {
            this.__updateItemsFocusable();
          }
        }
        /**
         * @param {!HTMLElement} dstCell
         * @protected
         */

      }, {
        key: "_scrollHorizontallyToCell",
        value: function _scrollHorizontallyToCell(dstCell) {
          if (dstCell.hasAttribute('frozen') || this.__isDetailsCell(dstCell)) {
            // These cells are, by design, always visible, no need to scroll.
            return;
          }

          var dstCellRect = dstCell.getBoundingClientRect();
          var dstRow = dstCell.parentNode;
          var dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
          var tableRect = this.$.table.getBoundingClientRect();
          var leftBoundary = tableRect.left,
              rightBoundary = tableRect.right;

          for (var i = dstCellIndex - 1; i >= 0; i--) {
            var cell = dstRow.children[i];

            if (cell.hasAttribute('hidden') || this.__isDetailsCell(cell)) {
              continue;
            }

            if (cell.hasAttribute('frozen')) {
              leftBoundary = cell.getBoundingClientRect().right;
              break;
            }
          }

          for (var _i = dstCellIndex + 1; _i < dstRow.children.length; _i++) {
            var _cell = dstRow.children[_i];

            if (_cell.hasAttribute('hidden') || this.__isDetailsCell(_cell)) {
              continue;
            }

            if (_cell.hasAttribute('frozen')) {
              rightBoundary = _cell.getBoundingClientRect().left;
              break;
            }
          }

          if (dstCellRect.left < leftBoundary) {
            this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
          }

          if (dstCellRect.right > rightBoundary) {
            this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
          }
        }
        /**
         * @typedef {Object} GridEventLocation
         * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
         * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
         * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
         * @private
         */

        /**
         * Takes an event and returns a location object describing in which part of the grid the event occurred.
         * The event may either target table section, a row, a cell or contents of a cell.
         * @param {Event} e
         * @returns {GridEventLocation}
         * @private
         */

      }, {
        key: "_getGridEventLocation",
        value: function _getGridEventLocation(e) {
          var path = e.composedPath();
          var tableIndex = path.indexOf(this.$.table); // Assuming ascending path to table is: [...,] th|td, tr, thead|tbody, table [,...]

          var section = tableIndex >= 1 ? path[tableIndex - 1] : null;
          var row = tableIndex >= 2 ? path[tableIndex - 2] : null;
          var cell = tableIndex >= 3 ? path[tableIndex - 3] : null;
          return {
            section: section,
            row: row,
            cell: cell
          };
        }
        /**
         * Helper method that maps a focus target cell to the containing grid section
         * @param {HTMLElement} focusTarget
         * @returns {HTMLTableSectionElement | null}
         * @private
         */

      }, {
        key: "_getGridSectionFromFocusTarget",
        value: function _getGridSectionFromFocusTarget(focusTarget) {
          if (focusTarget === this._headerFocusable) return this.$.header;
          if (focusTarget === this._itemsFocusable) return this.$.items;
          if (focusTarget === this._footerFocusable) return this.$.footer;
          return null;
        }
        /**
         * Fired when a cell is focused with click or keyboard navigation.
         *
         * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
         *
         * @event cell-focus
         */

      }], [{
        key: "properties",
        get: function get() {
          return {
            /** @private */
            _headerFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /**
             * @type {!HTMLElement | undefined}
             * @protected
             */
            _itemsFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /** @private */
            _footerFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /** @private */
            _navigatingIsHidden: Boolean,

            /**
             * @type {number}
             * @protected
             */
            _focusedItemIndex: {
              type: Number,
              value: 0
            },

            /** @private */
            _focusedColumnOrder: Number,

            /**
             * Indicates whether the grid is currently in interaction mode.
             * In interaction mode the user is currently interacting with a control,
             * such as an input or a select, within a cell.
             * In interaction mode keyboard navigation between cells is disabled.
             * Interaction mode also prevents the focus target cell of that section of
             * the grid from receiving focus, allowing the user to switch focus to
             * controls in adjacent cells, rather than focussing the outer cell
             * itself.
             * @type {boolean}
             * @private
             */
            interacting: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              readOnly: true,
              observer: '_interactingChanged'
            }
          };
        }
      }]);
      return KeyboardNavigationMixin;
    }(superClass);
  };

  _exports.KeyboardNavigationMixin = KeyboardNavigationMixin;
});