define(["exports", "../../../@polymer/polymer/lib/utils/case-map.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js"], function (_exports, _caseMap, _flattenedNodesObserver) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SlotController = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A controller for providing content to slot element and observing changes.
   */
  var SlotController = /*#__PURE__*/function (_EventTarget) {
    babelHelpers.inherits(SlotController, _EventTarget);

    var _super = _createSuper(SlotController);

    function SlotController(host, slotName, slotFactory, slotInitializer) {
      var _this;

      babelHelpers.classCallCheck(this, SlotController);
      _this = _super.call(this);
      _this.host = host;
      _this.slotName = slotName;
      _this.slotFactory = slotFactory;
      _this.slotInitializer = slotInitializer;
      _this.defaultId = SlotController.generateId(slotName, host);
      return _this;
    }
    /**
     * Ensure that every instance has unique ID.
     *
     * @param {string} slotName
     * @param {HTMLElement} host
     * @return {string}
     * @protected
     */


    babelHelpers.createClass(SlotController, [{
      key: "hostConnected",
      value: function hostConnected() {
        if (!this.initialized) {
          var node = this.getSlotChild();

          if (!node) {
            node = this.attachDefaultNode();
          } else {
            this.node = node;
            this.initCustomNode(node);
          }

          this.initNode(node); // TODO: Consider making this behavior opt-in to improve performance.

          this.observe();
          this.initialized = true;
        }
      }
      /**
       * Create and attach default node using the slot factory.
       * @return {Node | undefined}
       * @protected
       */

    }, {
      key: "attachDefaultNode",
      value: function attachDefaultNode() {
        var host = this.host,
            slotName = this.slotName,
            slotFactory = this.slotFactory; // Check if the node was created previously and if so, reuse it.

        var node = this.defaultNode; // Slot factory is optional, some slots don't have default content.

        if (!node && slotFactory) {
          node = slotFactory(host);

          if (babelHelpers.instanceof(node, Element)) {
            if (slotName !== '') {
              node.setAttribute('slot', slotName);
            }

            this.node = node;
            this.defaultNode = node;
          }
        }

        if (node) {
          host.appendChild(node);
        }

        return node;
      }
      /**
       * Return a reference to the node managed by the controller.
       * @return {Node}
       */

    }, {
      key: "getSlotChild",
      value: function getSlotChild() {
        var slotName = this.slotName;
        return Array.from(this.host.childNodes).find(function (node) {
          // Either an element (any slot) or a text node (only un-named slot).
          return node.nodeType === Node.ELEMENT_NODE && node.slot === slotName || node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === '';
        });
      }
      /**
       * @param {Node} node
       * @protected
       */

    }, {
      key: "initNode",
      value: function initNode(node) {
        var slotInitializer = this.slotInitializer; // Don't try to bind `this` to initializer (normally it's arrow function).
        // Instead, pass the host as a first argument to access component's state.

        if (slotInitializer) {
          slotInitializer(this.host, node);
        }
      }
      /**
       * Override to initialize the newly added custom node.
       *
       * @param {Node} _node
       * @protected
       */

    }, {
      key: "initCustomNode",
      value: function initCustomNode(_node) {}
      /**
       * Override to teardown slotted node when it's removed.
       *
       * @param {Node} _node
       * @protected
       */

    }, {
      key: "teardownNode",
      value: function teardownNode(_node) {}
      /**
       * Setup the observer to manage slot content changes.
       * @protected
       */

    }, {
      key: "observe",
      value: function observe() {
        var _this2 = this;

        var slotName = this.slotName;
        var selector = slotName === '' ? 'slot:not([name])' : "slot[name=".concat(slotName, "]");
        var slot = this.host.shadowRoot.querySelector(selector);
        this.__slotObserver = new _flattenedNodesObserver.FlattenedNodesObserver(slot, function (info) {
          // TODO: support default slot with multiple nodes (e.g. confirm-dialog)
          var current = _this2.node;
          var newNode = info.addedNodes.find(function (node) {
            return node !== current;
          });

          if (info.removedNodes.length) {
            info.removedNodes.forEach(function (node) {
              _this2.teardownNode(node);
            });
          }

          if (newNode) {
            // Custom node is added, remove the current one.
            if (current && current.isConnected) {
              _this2.host.removeChild(current);
            }

            _this2.node = newNode;

            if (newNode !== _this2.defaultNode) {
              _this2.initCustomNode(newNode);

              _this2.initNode(newNode);
            }
          }
        });
      }
    }], [{
      key: "generateId",
      value: function generateId(slotName, host) {
        var prefix = slotName || 'default'; // Support dash-case slot names e.g. "error-message"

        var field = "".concat((0, _caseMap.dashToCamelCase)(prefix), "Id"); // Maintain the unique ID counter for a given prefix.

        this[field] = 1 + this[field] || 0;
        return "".concat(prefix, "-").concat(host.localName, "-").concat(this[field]);
      }
    }]);
    return SlotController;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(EventTarget));

  _exports.SlotController = SlotController;
});