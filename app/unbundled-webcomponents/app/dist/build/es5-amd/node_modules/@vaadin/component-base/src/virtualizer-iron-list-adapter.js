define(["exports", "./async.js", "./browser-utils.js", "./debounce.js", "./iron-list-core.js"], function (_exports, _async, _browserUtils, _debounce, _ironListCore) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.IronListAdapter = void 0;

  /**
   * @license
   * Copyright (c) 2021 - 2022 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   */
  // iron-list can by default handle sizes up to around 100000.
  // When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used
  var MAX_VIRTUAL_COUNT = 100000;
  var OFFSET_ADJUST_MIN_THRESHOLD = 1000;

  var IronListAdapter = /*#__PURE__*/function () {
    function IronListAdapter(_ref) {
      var _this = this;

      var createElements = _ref.createElements,
          updateElement = _ref.updateElement,
          scrollTarget = _ref.scrollTarget,
          scrollContainer = _ref.scrollContainer,
          elementsContainer = _ref.elementsContainer,
          reorderElements = _ref.reorderElements;
      babelHelpers.classCallCheck(this, IronListAdapter);
      this.isAttached = true;
      this._vidxOffset = 0;
      this.createElements = createElements;
      this.updateElement = updateElement;
      this.scrollTarget = scrollTarget;
      this.scrollContainer = scrollContainer;
      this.elementsContainer = elementsContainer || scrollContainer;
      this.reorderElements = reorderElements; // Iron-list uses this value to determine how many pages of elements to render

      this._maxPages = 1.3;
      this.timeouts = {
        SCROLL_REORDER: 500,
        IGNORE_WHEEL: 500
      };
      this.__resizeObserver = new ResizeObserver(function () {
        return _this._resizeHandler();
      });

      if (getComputedStyle(this.scrollTarget).overflow === 'visible') {
        this.scrollTarget.style.overflow = 'auto';
      }

      if (getComputedStyle(this.scrollContainer).position === 'static') {
        this.scrollContainer.style.position = 'relative';
      }

      this.__resizeObserver.observe(this.scrollTarget);

      this.scrollTarget.addEventListener('scroll', function () {
        return _this._scrollHandler();
      });
      this._scrollLineHeight = this._getScrollLineHeight();
      this.scrollTarget.addEventListener('wheel', function (e) {
        return _this.__onWheel(e);
      });

      if (this.reorderElements) {
        // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.
        // Need to defer reordering until the user lets go of the scroll bar handle.
        this.scrollTarget.addEventListener('mousedown', function () {
          return _this.__mouseDown = true;
        });
        this.scrollTarget.addEventListener('mouseup', function () {
          _this.__mouseDown = false;

          if (_this.__pendingReorder) {
            _this.__reorderElements();
          }
        });
      }
    }

    babelHelpers.createClass(IronListAdapter, [{
      key: "_manageFocus",
      value: function _manageFocus() {}
    }, {
      key: "_removeFocusedItem",
      value: function _removeFocusedItem() {}
    }, {
      key: "scrollOffset",
      get: function get() {
        return 0;
      }
    }, {
      key: "adjustedFirstVisibleIndex",
      get: function get() {
        return this.firstVisibleIndex + this._vidxOffset;
      }
    }, {
      key: "adjustedLastVisibleIndex",
      get: function get() {
        return this.lastVisibleIndex + this._vidxOffset;
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(index) {
        if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {
          return;
        }

        index = this._clamp(index, 0, this.size - 1);

        var visibleElementCount = this.__getVisibleElements().length;

        var targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);

        if (this._virtualCount - targetVirtualIndex < visibleElementCount) {
          targetVirtualIndex = this._virtualCount - (this.size - index);
          this._vidxOffset = this.size - this._virtualCount;
        } else if (targetVirtualIndex < visibleElementCount) {
          if (index < OFFSET_ADJUST_MIN_THRESHOLD) {
            targetVirtualIndex = index;
            this._vidxOffset = 0;
          } else {
            targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;
            this._vidxOffset = index - targetVirtualIndex;
          }
        } else {
          this._vidxOffset = index - targetVirtualIndex;
        }

        this.__skipNextVirtualIndexAdjust = true;
        babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "scrollToIndex", this).call(this, targetVirtualIndex);

        if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {
          // Workaround an iron-list issue by manually adjusting the scroll position
          this._scrollTop -= this.__getIndexScrollOffset(index) || 0;
        }

        this._scrollHandler();
      }
    }, {
      key: "flush",
      value: function flush() {
        // The scroll target is hidden.
        if (this.scrollTarget.offsetHeight === 0) {
          return;
        }

        this._resizeHandler();

        (0, _debounce.flush)();

        this._scrollHandler();

        this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush();
        this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush();
      }
    }, {
      key: "update",
      value: function update() {
        var _this2 = this;

        var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var endIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size - 1;

        this.__getVisibleElements().forEach(function (el) {
          if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {
            _this2.__updateElement(el, el.__virtualIndex, true);
          }
        });
      }
    }, {
      key: "__updateElement",
      value: function __updateElement(el, index, forceSameIndexUpdates) {
        // Clean up temporary min height
        if (el.style.minHeight) {
          el.style.minHeight = '';
        }

        if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {
          this.updateElement(el, index);
          el.__lastUpdatedIndex = index;
        }

        if (el.offsetHeight === 0) {
          // If the elements have 0 height after update (for example due to lazy rendering),
          // it results in iron-list requesting to create an unlimited count of elements.
          // Assign a temporary min height to elements that would otherwise end up having
          // no height.
          el.style.minHeight = '200px';
        }
      }
    }, {
      key: "__getIndexScrollOffset",
      value: function __getIndexScrollOffset(index) {
        var element = this.__getVisibleElements().find(function (el) {
          return el.__virtualIndex === index;
        });

        return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__size;
      }
      /** @private */
      ,
      set: function set(size) {
        var _this3 = this;

        if (size === this.size) {
          return;
        } // Prevent element update while the scroll position is being restored


        this.__preventElementUpdates = true; // Record the scroll position before changing the size

        var fvi; // first visible index

        var fviOffsetBefore; // scroll offset of the first visible index

        if (size > 0) {
          fvi = this.adjustedFirstVisibleIndex;
          fviOffsetBefore = this.__getIndexScrollOffset(fvi);
        } // Change the size


        this.__size = size; // Flush before invoking items change to avoid
        // creating excess elements on the following flush()

        (0, _debounce.flush)();

        this._itemsChanged({
          path: 'items'
        });

        (0, _debounce.flush)(); // Try to restore the scroll position if the new size is larger than 0

        if (size > 0) {
          fvi = Math.min(fvi, size - 1);
          this.scrollToIndex(fvi);

          var fviOffsetAfter = this.__getIndexScrollOffset(fvi);

          if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {
            this._scrollTop += fviOffsetBefore - fviOffsetAfter;
          }
        }

        if (!this.elementsContainer.children.length) {
          requestAnimationFrame(function () {
            return _this3._resizeHandler();
          });
        }

        this.__preventElementUpdates = false; // Schedule and flush a resize handler

        this._resizeHandler();

        (0, _debounce.flush)();
      }
    }, {
      key: "_scrollTop",
      get: function get() {
        return this.scrollTarget.scrollTop;
      }
      /** @private */
      ,
      set: function set(top) {
        this.scrollTarget.scrollTop = top;
      }
      /** @private */

    }, {
      key: "items",
      get: function get() {
        return {
          length: Math.min(this.size, MAX_VIRTUAL_COUNT)
        };
      }
      /** @private */

    }, {
      key: "offsetHeight",
      get: function get() {
        return this.scrollTarget.offsetHeight;
      }
      /** @private */

    }, {
      key: "$",
      get: function get() {
        return {
          items: this.scrollContainer
        };
      }
      /** @private */

    }, {
      key: "updateViewportBoundaries",
      value: function updateViewportBoundaries() {
        var styles = window.getComputedStyle(this.scrollTarget);
        this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);
        this._isRTL = Boolean(styles.direction === 'rtl');
        this._viewportWidth = this.elementsContainer.offsetWidth;
        this._viewportHeight = this.scrollTarget.offsetHeight;
        this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;
        this.grid && this._updateGridMetrics();
      }
      /** @private */

    }, {
      key: "setAttribute",
      value: function setAttribute() {}
      /** @private */

    }, {
      key: "_createPool",
      value: function _createPool(size) {
        var _this4 = this;

        var physicalItems = this.createElements(size);
        var fragment = document.createDocumentFragment();
        physicalItems.forEach(function (el) {
          el.style.position = 'absolute';
          fragment.appendChild(el);

          _this4.__resizeObserver.observe(el);
        });
        this.elementsContainer.appendChild(fragment);
        return physicalItems;
      }
      /** @private */

    }, {
      key: "_assignModels",
      value: function _assignModels(itemSet) {
        var _this5 = this;

        this._iterateItems(function (pidx, vidx) {
          var el = _this5._physicalItems[pidx];
          el.hidden = vidx >= _this5.size;

          if (!el.hidden) {
            el.__virtualIndex = vidx + (_this5._vidxOffset || 0);

            _this5.__updateElement(el, el.__virtualIndex);
          } else {
            delete el.__lastUpdatedIndex;
          }
        }, itemSet);
      }
      /** @private */

    }, {
      key: "_isClientFull",
      value: function _isClientFull() {
        var _this6 = this;

        // Workaround an issue in iron-list that can cause it to freeze on fast scroll
        setTimeout(function () {
          return _this6.__clientFull = true;
        });
        return this.__clientFull || babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "_isClientFull", this).call(this);
      }
      /** @private */

    }, {
      key: "translate3d",
      value: function translate3d(_x, y, _z, el) {
        el.style.transform = "translateY(".concat(y, ")");
      }
      /** @private */

    }, {
      key: "toggleScrollListener",
      value: function toggleScrollListener() {}
    }, {
      key: "_scrollHandler",
      value: function _scrollHandler() {
        var _this7 = this;

        this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));

        babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "_scrollHandler", this).call(this);

        if (this.reorderElements) {
          this.__scrollReorderDebouncer = _debounce.Debouncer.debounce(this.__scrollReorderDebouncer, _async.timeOut.after(this.timeouts.SCROLL_REORDER), function () {
            return _this7.__reorderElements();
          });
        }

        this.__previousScrollTop = this._scrollTop;
      }
      /** @private */

    }, {
      key: "__onWheel",
      value: function __onWheel(e) {
        var _this8 = this;

        if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
          return;
        }

        var deltaY = e.deltaY;

        if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {
          // Scrolling by "lines of text" instead of pixels
          deltaY *= this._scrollLineHeight;
        } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
          // Scrolling by "pages" instead of pixels
          deltaY *= this._scrollPageHeight;
        }

        this._deltaYAcc = this._deltaYAcc || 0;

        if (this._wheelAnimationFrame) {
          // Accumulate wheel delta while a frame is being processed
          this._deltaYAcc += deltaY;
          e.preventDefault();
          return;
        }

        deltaY += this._deltaYAcc;
        this._deltaYAcc = 0;
        this._wheelAnimationFrame = true;
        this.__debouncerWheelAnimationFrame = _debounce.Debouncer.debounce(this.__debouncerWheelAnimationFrame, _async.animationFrame, function () {
          return _this8._wheelAnimationFrame = false;
        });
        var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);

        if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {
          e.preventDefault();
          this.scrollTarget.scrollTop += deltaY;
          this.scrollTarget.scrollLeft += e.deltaX;
          this._hasResidualMomentum = true;
          this._ignoreNewWheel = true;
          this._debouncerIgnoreNewWheel = _debounce.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async.timeOut.after(this.timeouts.IGNORE_WHEEL), function () {
            return _this8._ignoreNewWheel = false;
          });
        } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
          e.preventDefault();
        } else if (momentum > this._previousMomentum) {
          this._hasResidualMomentum = false;
        }

        this._previousMomentum = momentum;
      }
      /**
       * Determines if the element has an ancestor that handles the scroll delta prior to this
       *
       * @private
       */

    }, {
      key: "_hasScrolledAncestor",
      value: function _hasScrolledAncestor(el, deltaX, deltaY) {
        if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {
          return false;
        } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {
          return true;
        } else if (el !== this && el.parentElement) {
          return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
        }
      }
    }, {
      key: "_canScroll",
      value: function _canScroll(el, deltaX, deltaY) {
        return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
      }
      /**
       * @returns {Number|undefined} - The browser's default font-size in pixels
       * @private
       */

    }, {
      key: "_getScrollLineHeight",
      value: function _getScrollLineHeight() {
        var el = document.createElement('div');
        el.style.fontSize = 'initial';
        el.style.display = 'none';
        document.body.appendChild(el);
        var fontSize = window.getComputedStyle(el).fontSize;
        document.body.removeChild(el);
        return fontSize ? window.parseInt(fontSize) : undefined;
      }
    }, {
      key: "__getVisibleElements",
      value: function __getVisibleElements() {
        return Array.from(this.elementsContainer.children).filter(function (element) {
          return !element.hidden;
        });
      }
      /** @private */

    }, {
      key: "__reorderElements",
      value: function __reorderElements() {
        var _this9 = this;

        if (this.__mouseDown) {
          this.__pendingReorder = true;
          return;
        }

        this.__pendingReorder = false;
        var adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0); // Which row to use as a target?

        var visibleElements = this.__getVisibleElements();

        var elementWithFocus = visibleElements.find(function (element) {
          return element.contains(_this9.elementsContainer.getRootNode().activeElement) || element.contains(_this9.scrollTarget.getRootNode().activeElement);
        });
        var targetElement = elementWithFocus || visibleElements[0];

        if (!targetElement) {
          // All elements are hidden, don't reorder
          return;
        } // Where the target row should be?


        var targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart; // Reodrer the DOM elements to keep the target row at the target physical index

        var delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;

        if (delta > 0) {
          for (var i = 0; i < delta; i++) {
            this.elementsContainer.appendChild(visibleElements[i]);
          }
        } else if (delta < 0) {
          for (var _i = visibleElements.length + delta; _i < visibleElements.length; _i++) {
            this.elementsContainer.insertBefore(visibleElements[_i], visibleElements[0]);
          }
        } // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear
        // on Safari when using sticky positioning in case the scroll target is inside a flexbox.
        // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)


        if (_browserUtils.isSafari) {
          var transform = this.scrollTarget.style.transform;
          this.scrollTarget.style.transform = 'translateZ(0)';
          setTimeout(function () {
            return _this9.scrollTarget.style.transform = transform;
          });
        }
      }
      /** @private */

    }, {
      key: "_adjustVirtualIndexOffset",
      value: function _adjustVirtualIndexOffset(delta) {
        if (this._virtualCount >= this.size) {
          this._vidxOffset = 0;
        } else if (this.__skipNextVirtualIndexAdjust) {
          this.__skipNextVirtualIndexAdjust = false;
          return;
        } else if (Math.abs(delta) > 10000) {
          // Process a large scroll position change
          var scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);
          var offset = scale * this.size;
          this._vidxOffset = Math.round(offset - scale * this._virtualCount);
        } else {
          // Make sure user can always swipe/wheel scroll to the start and end
          var oldOffset = this._vidxOffset;
          var threshold = OFFSET_ADJUST_MIN_THRESHOLD;
          var maxShift = 100; // Near start

          if (this._scrollTop === 0) {
            this._vidxOffset = 0;

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "scrollToIndex", this).call(this, 0);
            }
          } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
            this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
            babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "scrollToIndex", this).call(this, this.firstVisibleIndex + (oldOffset - this._vidxOffset));
          } // Near end


          var maxOffset = this.size - this._virtualCount;

          if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {
            this._vidxOffset = maxOffset;

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "scrollToIndex", this).call(this, this._virtualCount - 1);
            }
          } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
            this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
            babelHelpers.get(babelHelpers.getPrototypeOf(IronListAdapter.prototype), "scrollToIndex", this).call(this, this.firstVisibleIndex - (this._vidxOffset - oldOffset));
          }
        }
      }
    }]);
    return IronListAdapter;
  }();

  _exports.IronListAdapter = IronListAdapter;
  Object.setPrototypeOf(IronListAdapter.prototype, _ironListCore.ironList);
});