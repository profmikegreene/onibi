define(["exports", "../../../@polymer/polymer/lib/utils/mixin.js"], function (_exports, _mixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FocusMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // We consider the keyboard to be active if the window has received a keydown
  // event since the last mousedown event.
  var keyboardActive = false; // Listen for top-level keydown and mousedown events.
  // Use capture phase so we detect events even if they're handled.

  window.addEventListener('keydown', function () {
    keyboardActive = true;
  }, {
    capture: true
  });
  window.addEventListener('mousedown', function () {
    keyboardActive = false;
  }, {
    capture: true
  });
  /**
   * A mixin to handle `focused` and `focus-ring` attributes based on focus.
   *
   * @polymerMixin
   */

  var FocusMixin = (0, _mixin.dedupingMixin)(function (superclass) {
    return /*#__PURE__*/function (_superclass) {
      babelHelpers.inherits(FocusMixinClass, _superclass);

      var _super = _createSuper(FocusMixinClass);

      function FocusMixinClass() {
        babelHelpers.classCallCheck(this, FocusMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(FocusMixinClass, [{
        key: "_keyboardActive",
        get:
        /**
         * @protected
         * @return {boolean}
         */
        function get() {
          return keyboardActive;
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this = this;

          this.addEventListener('focusin', function (e) {
            if (_this._shouldSetFocus(e)) {
              _this._setFocused(true);
            }
          });
          this.addEventListener('focusout', function (e) {
            if (_this._shouldRemoveFocus(e)) {
              _this._setFocused(false);
            }
          }); // In super.ready() other 'focusin' and 'focusout' listeners might be
          // added, so we call it after our own ones to ensure they execute first.
          // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the
          // input field on iOS after “Done” is pressed.

          babelHelpers.get(babelHelpers.getPrototypeOf(FocusMixinClass.prototype), "ready", this).call(this);
        }
        /** @protected */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(FocusMixinClass.prototype), "disconnectedCallback", this).call(this); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.
          // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

          if (this.hasAttribute('focused')) {
            this._setFocused(false);
          }
        }
        /**
         * Override to change how focused and focus-ring attributes are set.
         *
         * @param {boolean} focused
         * @protected
         */

      }, {
        key: "_setFocused",
        value: function _setFocused(focused) {
          this.toggleAttribute('focused', focused); // focus-ring is true when the element was focused from the keyboard.
          // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI

          this.toggleAttribute('focus-ring', focused && this._keyboardActive);
        }
        /**
         * Override to define if the field receives focus based on the event.
         *
         * @param {FocusEvent} _event
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_shouldSetFocus",
        value: function _shouldSetFocus(_event) {
          return true;
        }
        /**
         * Override to define if the field loses focus based on the event.
         *
         * @param {FocusEvent} _event
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_shouldRemoveFocus",
        value: function _shouldRemoveFocus(_event) {
          return true;
        }
      }]);
      return FocusMixinClass;
    }(superclass);
  });
  _exports.FocusMixin = FocusMixin;
});