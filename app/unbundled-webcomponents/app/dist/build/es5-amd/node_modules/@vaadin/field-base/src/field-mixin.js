define(["exports", "../../component-base/src/async.js", "../../component-base/src/controller-mixin.js", "../../component-base/src/debounce.js", "./error-controller.js", "./field-aria-controller.js", "./helper-controller.js", "./label-mixin.js", "./validate-mixin.js"], function (_exports, _async, _controllerMixin, _debounce, _errorController, _fieldAriaController, _helperController, _labelMixin, _validateMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FieldMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to provide common field logic: label, error message and helper text.
   *
   * @polymerMixin
   * @mixes ControllerMixin
   * @mixes LabelMixin
   * @mixes ValidateMixin
   */
  var FieldMixin = function FieldMixin(superclass) {
    return /*#__PURE__*/function (_ValidateMixin) {
      babelHelpers.inherits(FieldMixinClass, _ValidateMixin);

      var _super = _createSuper(FieldMixinClass);

      function FieldMixinClass() {
        var _this;

        babelHelpers.classCallCheck(this, FieldMixinClass);
        _this = _super.call(this);
        _this._fieldAriaController = new _fieldAriaController.FieldAriaController(babelHelpers.assertThisInitialized(_this));
        _this._helperController = new _helperController.HelperController(babelHelpers.assertThisInitialized(_this));
        _this._errorController = new _errorController.ErrorController(babelHelpers.assertThisInitialized(_this));

        _this.addController(_this._fieldAriaController);

        _this.addController(_this._helperController);

        _this.addController(_this._errorController);

        _this._labelController.addEventListener('label-changed', function (event) {
          var _event$detail = event.detail,
              hasLabel = _event$detail.hasLabel,
              node = _event$detail.node;

          _this.__labelChanged(hasLabel, node);
        });

        _this._helperController.addEventListener('helper-changed', function (event) {
          var _event$detail2 = event.detail,
              hasHelper = _event$detail2.hasHelper,
              node = _event$detail2.node;

          _this.__helperChanged(hasHelper, node);
        });

        return _this;
      }
      /** @private */


      babelHelpers.createClass(FieldMixinClass, [{
        key: "_errorId",
        get:
        /** @protected */
        function get() {
          return this._errorController.errorId;
        }
        /**
         * @protected
         * @return {HTMLElement}
         */

      }, {
        key: "_errorNode",
        get: function get() {
          return this._errorController.node;
        }
        /** @protected */

      }, {
        key: "_helperId",
        get: function get() {
          return this._helperController.helperId;
        }
        /**
         * @protected
         * @return {HTMLElement}
         */

      }, {
        key: "_helperNode",
        get: function get() {
          return this._helperController.node;
        }
      }, {
        key: "__helperChanged",
        value: function __helperChanged(hasHelper, helperNode) {
          if (hasHelper) {
            this._fieldAriaController.setHelperId(helperNode.id);
          } else {
            this._fieldAriaController.setHelperId(null);
          }
        }
        /**
         * Dispatch an event if a specific size measurement property has changed.
         * Supporting multiple properties here is needed for `vaadin-text-area`.
         * @protected
         */

      }, {
        key: "_dispatchIronResizeEventIfNeeded",
        value: function _dispatchIronResizeEventIfNeeded(prop, value) {
          var oldSize = '__old' + prop;

          if (this[oldSize] !== undefined && this[oldSize] !== value) {
            this.dispatchEvent(new CustomEvent('iron-resize', {
              bubbles: true,
              composed: true
            }));
          }

          this[oldSize] = value;
        }
        /** @private */

      }, {
        key: "__observeOffsetHeight",
        value: function __observeOffsetHeight() {
          var _this2 = this;

          this.__observeOffsetHeightDebouncer = _debounce.Debouncer.debounce(this.__observeOffsetHeightDebouncer, _async.animationFrame, function () {
            _this2._dispatchIronResizeEventIfNeeded('Height', _this2.offsetHeight);
          });
        }
        /** @private */

      }, {
        key: "__labelChanged",
        value: function __labelChanged(hasLabel, labelNode) {
          // Label ID should be only added when the label content is present.
          // Otherwise, it may conflict with an `aria-label` attribute possibly added by the user.
          if (hasLabel) {
            this._fieldAriaController.setLabelId(labelNode.id);
          } else {
            this._fieldAriaController.setLabelId(null);
          }
        }
        /**
         * @param {string | null | undefined} errorMessage
         * @protected
         */

      }, {
        key: "_errorMessageChanged",
        value: function _errorMessageChanged(errorMessage) {
          this._errorController.setErrorMessage(errorMessage);
        }
        /**
         * @param {string} helperText
         * @protected
         */

      }, {
        key: "_helperTextChanged",
        value: function _helperTextChanged(helperText) {
          this._helperController.setHelperText(helperText);
        }
        /**
         * @param {HTMLElement | null | undefined} target
         * @protected
         */

      }, {
        key: "_ariaTargetChanged",
        value: function _ariaTargetChanged(target) {
          if (target) {
            this._fieldAriaController.setTarget(target);
          }
        }
        /**
         * @param {boolean} required
         * @protected
         */

      }, {
        key: "_requiredChanged",
        value: function _requiredChanged(required) {
          this._fieldAriaController.setRequired(required);
        }
        /**
         * @param {boolean} required
         * @protected
         */

      }, {
        key: "_invalidChanged",
        value: function _invalidChanged(invalid) {
          var _this3 = this;

          this._errorController.setInvalid(invalid); // This timeout is needed to prevent NVDA from announcing the error message twice:
          // 1. Once adding the `[role=alert]` attribute by the `_updateErrorMessage` method (OK).
          // 2. Once linking the error ID with the ARIA target here (unwanted).
          // Related issue: https://github.com/vaadin/web-components/issues/3061.


          setTimeout(function () {
            // Error message ID needs to be dynamically added / removed based on the validity
            // Otherwise assistive technologies would announce the error, even if we hide it.
            if (invalid) {
              _this3._fieldAriaController.setErrorId(_this3._errorController.errorId);
            } else {
              _this3._fieldAriaController.setErrorId(null);
            }
          });
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * A target element to which ARIA attributes are set.
             * @protected
             */
            ariaTarget: {
              type: Object,
              observer: '_ariaTargetChanged'
            },

            /**
             * Error to show when the field is invalid.
             *
             * @attr {string} error-message
             */
            errorMessage: {
              type: String,
              observer: '_errorMessageChanged'
            },

            /**
             * String used for the helper text.
             * @attr {string} helper-text
             */
            helperText: {
              type: String,
              observer: '_helperTextChanged'
            },

            /** @protected */
            _helperId: String
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['__observeOffsetHeight(errorMessage, invalid, label, helperText)', '_invalidChanged(invalid)', '_requiredChanged(required)'];
        }
      }]);
      return FieldMixinClass;
    }((0, _validateMixin.ValidateMixin)((0, _labelMixin.LabelMixin)((0, _controllerMixin.ControllerMixin)(superclass))));
  };

  _exports.FieldMixin = FieldMixin;
});