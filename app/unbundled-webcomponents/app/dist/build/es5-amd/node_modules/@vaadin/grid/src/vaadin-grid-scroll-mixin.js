define(["exports", "../../component-base/src/async.js", "../../component-base/src/debounce.js"], function (_exports, _async, _debounce) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ScrollMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var timeouts = {
    SCROLLING: 500
  };
  /**
   * @polymerMixin
   */

  var ScrollMixin = function ScrollMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(ScrollMixin, _superClass);

      var _super = _createSuper(ScrollMixin);

      function ScrollMixin() {
        babelHelpers.classCallCheck(this, ScrollMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(ScrollMixin, [{
        key: "_scrollTop",
        get:
        /** @private */
        function get() {
          return this.$.table.scrollTop;
        }
        /** @private */
        ,
        set:
        /**
         * Override (from iron-scroll-target-behavior) to avoid document scroll
         * @private
         */
        function set(top) {
          this.$.table.scrollTop = top;
        }
      }, {
        key: "_scrollLeft",
        get: function get() {
          return this.$.table.scrollLeft;
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "ready", this).call(this); // Preserve accessor to the legacy scrolling functionality

          this.$.outerscroller = document.createElement('div');
          this.scrollTarget = this.$.table;
          this.$.items.addEventListener('focusin', function (e) {
            var itemsIndex = e.composedPath().indexOf(_this.$.items);
            _this._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
          });
          this.$.items.addEventListener('focusout', function () {
            return _this._rowWithFocusedElement = undefined;
          });
          this.$.table.addEventListener('scroll', function () {
            return _this._afterScroll();
          });
        }
        /**
         * Scroll to a specific row index in the virtual list. Note that the row index is
         * not always the same for any particular item. For example, sorting/filtering/expanding
         * or collapsing hierarchical items can affect the row index related to an item.
         *
         * @param {number} index Row index to scroll to
         */

      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index) {
          index = Math.min(this._effectiveSize - 1, Math.max(0, index));

          this.__virtualizer.scrollToIndex(index);

          this.__scrollIntoViewport(index);
        }
        /**
         * Makes sure the row with the given index (if found in the DOM) is fully
         * inside the visible viewport, taking header/footer into account.
         * @private
         */

      }, {
        key: "__scrollIntoViewport",
        value: function __scrollIntoViewport(index) {
          var rowElement = babelHelpers.toConsumableArray(this.$.items.children).find(function (child) {
            return child.index === index;
          });

          if (rowElement) {
            var dstRect = rowElement.getBoundingClientRect();
            var footerTop = this.$.footer.getBoundingClientRect().top;
            var headerBottom = this.$.header.getBoundingClientRect().bottom;

            if (dstRect.bottom > footerTop) {
              this.$.table.scrollTop += dstRect.bottom - footerTop;
            } else if (dstRect.top < headerBottom) {
              this.$.table.scrollTop -= headerBottom - dstRect.top;
            }
          }
        }
        /** @private */

      }, {
        key: "_scheduleScrolling",
        value: function _scheduleScrolling() {
          var _this2 = this;

          if (!this._scrollingFrame) {
            // Defer setting state attributes to avoid Edge hiccups
            this._scrollingFrame = requestAnimationFrame(function () {
              return _this2.$.scroller.toggleAttribute('scrolling', true);
            });
          }

          this._debounceScrolling = _debounce.Debouncer.debounce(this._debounceScrolling, _async.timeOut.after(timeouts.SCROLLING), function () {
            cancelAnimationFrame(_this2._scrollingFrame);
            delete _this2._scrollingFrame;

            _this2.$.scroller.toggleAttribute('scrolling', false);
          });
        }
        /** @private */

      }, {
        key: "_afterScroll",
        value: function _afterScroll() {
          this.__updateHorizontalScrollPosition();

          if (!this.hasAttribute('reordering')) {
            this._scheduleScrolling();
          }

          this._updateOverflow();
        }
        /** @private */

      }, {
        key: "_updateOverflow",
        value: function _updateOverflow() {
          var _this3 = this;

          // Set overflow styling attributes
          var overflow = '';
          var table = this.$.table;

          if (table.scrollTop < table.scrollHeight - table.clientHeight) {
            overflow += ' bottom';
          }

          if (table.scrollTop > 0) {
            overflow += ' top';
          }

          if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
            overflow += ' right';
          }

          if (table.scrollLeft > 0) {
            overflow += ' left';
          }

          this._debounceOverflow = _debounce.Debouncer.debounce(this._debounceOverflow, _async.animationFrame, function () {
            var value = overflow.trim();

            if (value.length > 0 && _this3.getAttribute('overflow') !== value) {
              _this3.setAttribute('overflow', value);
            } else if (value.length == 0 && _this3.hasAttribute('overflow')) {
              _this3.removeAttribute('overflow');
            }
          });
        }
        /** @protected */

      }, {
        key: "_frozenCellsChanged",
        value: function _frozenCellsChanged() {
          var _this4 = this;

          this._debouncerCacheElements = _debounce.Debouncer.debounce(this._debouncerCacheElements, _async.microTask, function () {
            Array.from(_this4.shadowRoot.querySelectorAll('[part~="cell"]')).forEach(function (cell) {
              cell.style.transform = '';
            });
            _this4._frozenCells = Array.prototype.slice.call(_this4.$.table.querySelectorAll('[frozen]'));

            _this4.__updateHorizontalScrollPosition();
          });

          this._updateLastFrozen();
        }
        /** @protected */

      }, {
        key: "_updateLastFrozen",
        value: function _updateLastFrozen() {
          if (!this._columnTree) {
            return;
          }

          var columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);

          columnsRow.sort(function (a, b) {
            return a._order - b._order;
          });
          var lastFrozen = columnsRow.reduce(function (prev, col, index) {
            col._lastFrozen = false;
            return col.frozen && !col.hidden ? index : prev;
          }, undefined);

          if (lastFrozen !== undefined) {
            columnsRow[lastFrozen]._lastFrozen = true;
          }
        }
        /** @private */

      }, {
        key: "__updateHorizontalScrollPosition",
        value: function __updateHorizontalScrollPosition() {
          this.$.table.style.setProperty('--_grid-horizontal-scroll-position', -this._scrollLeft + 'px');

          if (this.__isRTL) {
            // Translating the sticky sections using a CSS variable works nicely on LTR.
            // On RTL, it causes jumpy behavior (on Desktop Safari) so we need to translate manually.
            var x = this.__getNormalizedScrollLeft(this.$.table) + this.$.table.clientWidth - this.$.table.scrollWidth;
            var transform = "translate(".concat(x, "px, 0)");

            for (var i = 0; i < this._frozenCells.length; i++) {
              this._frozenCells[i].style.transform = transform;
            }
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Cached array of frozen cells
             * @private
             */
            _frozenCells: {
              type: Array,
              value: function value() {
                return [];
              }
            },

            /** @private */
            _rowWithFocusedElement: Element
          };
        }
      }]);
      return ScrollMixin;
    }(superClass);
  };

  _exports.ScrollMixin = ScrollMixin;
});