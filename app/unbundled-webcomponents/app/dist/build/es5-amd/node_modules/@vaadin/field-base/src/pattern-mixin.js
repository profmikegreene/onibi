define(["exports", "../../component-base/src/async.js", "../../component-base/src/debounce.js", "./input-constraints-mixin.js"], function (_exports, _async, _debounce, _inputConstraintsMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PatternMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to provide `pattern` and `preventInvalidInput` properties.
   *
   * @polymerMixin
   * @mixes InputConstraintsMixin
   */
  var PatternMixin = function PatternMixin(superclass) {
    return /*#__PURE__*/function (_InputConstraintsMixi) {
      babelHelpers.inherits(PatternMixinClass, _InputConstraintsMixi);

      var _super = _createSuper(PatternMixinClass);

      function PatternMixinClass() {
        babelHelpers.classCallCheck(this, PatternMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(PatternMixinClass, [{
        key: "_checkInputValue",
        value:
        /** @private */
        function _checkInputValue() {
          var _this = this;

          if (this.preventInvalidInput) {
            var input = this.inputElement;

            if (input && input.value.length > 0 && !this.checkValidity()) {
              input.value = this.value || ''; // add input-prevented attribute for 200ms

              this.setAttribute('input-prevented', '');
              this._inputDebouncer = _debounce.Debouncer.debounce(this._inputDebouncer, _async.timeOut.after(200), function () {
                _this.removeAttribute('input-prevented');
              });
              return;
            }
          }
        }
        /**
         * @param {Event} event
         * @protected
         */

      }, {
        key: "_onInput",
        value: function _onInput(event) {
          this._checkInputValue();

          babelHelpers.get(babelHelpers.getPrototypeOf(PatternMixinClass.prototype), "_onInput", this).call(this, event);
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * A regular expression that the value is checked against.
             * The pattern must match the entire value, not just some subset.
             */
            pattern: {
              type: String
            },

            /**
             * When set to true, user is prevented from typing a value that
             * conflicts with the given `pattern`.
             * @attr {boolean} prevent-invalid-input
             */
            preventInvalidInput: {
              type: Boolean
            }
          };
        }
      }, {
        key: "delegateAttrs",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(PatternMixinClass), "delegateAttrs", this)), ['pattern']);
        }
      }, {
        key: "constraints",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(PatternMixinClass), "constraints", this)), ['pattern']);
        }
      }]);
      return PatternMixinClass;
    }((0, _inputConstraintsMixin.InputConstraintsMixin)(superclass));
  };

  _exports.PatternMixin = PatternMixin;
});