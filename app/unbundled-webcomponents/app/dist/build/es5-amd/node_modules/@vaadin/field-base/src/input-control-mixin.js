define(["exports", "../../component-base/src/keyboard-mixin.js", "./delegate-focus-mixin.js", "./field-mixin.js", "./input-constraints-mixin.js"], function (_exports, _keyboardMixin, _delegateFocusMixin, _fieldMixin, _inputConstraintsMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.InputControlMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to provide shared logic for the editable form input controls.
   *
   * @polymerMixin
   * @mixes DelegateFocusMixin
   * @mixes FieldMixin
   * @mixes InputConstraintsMixin
   * @mixes KeyboardMixin
   */
  var InputControlMixin = function InputControlMixin(superclass) {
    return /*#__PURE__*/function (_DelegateFocusMixin) {
      babelHelpers.inherits(InputControlMixinClass, _DelegateFocusMixin);

      var _super = _createSuper(InputControlMixinClass);

      function InputControlMixinClass() {
        babelHelpers.classCallCheck(this, InputControlMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(InputControlMixinClass, [{
        key: "clearElement",
        get:
        /**
         * Any element extending this mixin is required to implement this getter.
         * It returns the reference to the clear button element.
         * @protected
         * @return {Element | null | undefined}
         */
        function get() {
          console.warn("Please implement the 'clearElement' property in <".concat(this.localName, ">"));
          return null;
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(InputControlMixinClass.prototype), "ready", this).call(this);

          if (this.clearElement) {
            this.clearElement.addEventListener('click', function (e) {
              return _this._onClearButtonClick(e);
            });
          }
        }
        /**
         * @param {Event} event
         * @protected
         */

      }, {
        key: "_onClearButtonClick",
        value: function _onClearButtonClick(event) {
          event.preventDefault();
          this.inputElement.focus();

          this.__clear();
        }
        /**
         * Override an event listener from `DelegateFocusMixin`.
         * @param {FocusEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onFocus",
        value: function _onFocus(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputControlMixinClass.prototype), "_onFocus", this).call(this, event);

          if (this.autoselect && this.inputElement) {
            this.inputElement.select();
          }
        }
        /**
         * Override an event listener inherited from `KeydownMixin` to clear on Esc.
         * Components that extend this mixin can prevent this behavior by overriding
         * this method without calling `super._onKeyDown` to provide custom logic.
         * @param {KeyboardEvent} event
         * @protected
         * @override
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputControlMixinClass.prototype), "_onKeyDown", this).call(this, event);

          if (event.key === 'Escape' && this.clearButtonVisible && !!this.value) {
            this.__clear();
          }
        }
        /**
         * Override an event listener inherited from `InputMixin`
         * to capture native `change` event and make sure that
         * a new one is dispatched after validation runs.
         * @param {Event} event
         * @protected
         * @override
         */

      }, {
        key: "_onChange",
        value: function _onChange(event) {
          event.stopPropagation();
          this.validate();
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              sourceEvent: event
            },
            bubbles: event.bubbles,
            cancelable: event.cancelable
          }));
        }
        /** @private */

      }, {
        key: "__clear",
        value: function __clear() {
          this.clear();
          this.inputElement.dispatchEvent(new Event('input', {
            bubbles: true,
            composed: true
          }));
          this.inputElement.dispatchEvent(new Event('change', {
            bubbles: true
          }));
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * If true, the input text gets fully selected when the field is focused using click or touch / tap.
             */
            autoselect: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to display the clear icon which clears the input.
             * @attr {boolean} clear-button-visible
             */
            clearButtonVisible: {
              type: Boolean,
              reflectToAttribute: true,
              value: false
            },

            /**
             * The name of this field.
             */
            name: {
              type: String,
              reflectToAttribute: true
            },

            /**
             * A hint to the user of what can be entered in the field.
             */
            placeholder: {
              type: String,
              reflectToAttribute: true
            },

            /**
             * When present, it specifies that the field is read-only.
             */
            readonly: {
              type: Boolean,
              value: false,
              reflectToAttribute: true
            },

            /**
             * The text usually displayed in a tooltip popup when the mouse is over the field.
             */
            title: {
              type: String,
              reflectToAttribute: true
            }
          };
        }
      }, {
        key: "delegateAttrs",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(InputControlMixinClass), "delegateAttrs", this)), ['name', 'type', 'placeholder', 'readonly', 'invalid', 'title']);
        }
      }]);
      return InputControlMixinClass;
    }((0, _delegateFocusMixin.DelegateFocusMixin)((0, _inputConstraintsMixin.InputConstraintsMixin)((0, _fieldMixin.FieldMixin)((0, _keyboardMixin.KeyboardMixin)(superclass)))));
  };

  _exports.InputControlMixin = InputControlMixin;
});