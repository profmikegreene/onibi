define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../component-base/src/element-mixin.js", "./vaadin-icon-svg.js"], function (_exports, _polymerElement, _elementMixin, _vaadinIconSvg) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Iconset = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var iconRegistry = {};
  /**
   * `<vaadin-iconset>` is a Web Component for creating SVG icon collections.
   *
   * @extends HTMLElement
   * @mixes ElementMixin
   */

  var Iconset = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(Iconset, _ElementMixin);

    var _super = _createSuper(Iconset);

    function Iconset() {
      babelHelpers.classCallCheck(this, Iconset);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(Iconset, [{
      key: "connectedCallback",
      value:
      /** @protected */
      function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(Iconset.prototype), "connectedCallback", this).call(this);
        this.style.display = 'none';
      }
      /**
       * Produce SVGTemplateResult for the element matching `name` in this
       * iconset, or `undefined` if there is no matching element.
       *
       * @param {string} name
       */

    }, {
      key: "applyIcon",
      value: function applyIcon(name) {
        // create the icon map on-demand, since the iconset itself has no discrete
        // signal to know when it's children are fully parsed
        this._icons = this._icons || this.__createIconMap();
        return {
          svg: (0, _vaadinIconSvg.cloneSvgNode)(this._icons[this.__getIconId(name)]),
          size: this.size
        };
      }
      /**
       * Create a map of child SVG elements by id.
       */

    }, {
      key: "__createIconMap",
      value: function __createIconMap() {
        var _this = this;

        var icons = {};
        this.querySelectorAll('[id]').forEach(function (icon) {
          icons[_this.__getIconId(icon.id)] = icon;
        });
        return icons;
      }
      /** @private */

    }, {
      key: "__getIconId",
      value: function __getIconId(id) {
        return (id || '').replace("".concat(this.name, ":"), '');
      }
      /** @private */

    }, {
      key: "__nameChanged",
      value: function __nameChanged(name, oldName) {
        if (oldName) {
          iconRegistry[name] = Iconset.getIconset(oldName);
          delete iconRegistry[oldName];
        }

        if (name) {
          iconRegistry[name] = this;
          document.dispatchEvent(new CustomEvent('vaadin-iconset-registered', {
            detail: name
          }));
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return null;
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-iconset';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * The name of the iconset. Every iconset is required to have its own unique name.
           * All the SVG icons in the iconset must have IDs conforming to its name.
           *
           * See also [`name`](#/elements/vaadin-icon#property-name) property of `vaadin-icon`.
           */
          name: {
            type: String,
            observer: '__nameChanged'
          },

          /**
           * The size of an individual icon. Note that icons must be square.
           *
           * When using `vaadin-icon`, the size of the iconset will take precedence
           * over the size defined by the user to ensure correct appearance.
           */
          size: {
            type: Number,
            value: 24
          }
        };
      }
      /**
       * Create an instance of the iconset.
       *
       * @param {string} name
       */

    }, {
      key: "getIconset",
      value: function getIconset(name) {
        var iconset = iconRegistry[name];

        if (!iconset) {
          iconset = document.createElement('vaadin-iconset');
          iconset.name = name;
          iconRegistry[name] = iconset;
        }

        return iconset;
      }
    }]);
    return Iconset;
  }((0, _elementMixin.ElementMixin)(_polymerElement.PolymerElement));

  _exports.Iconset = Iconset;
  customElements.define(Iconset.is, Iconset);
});