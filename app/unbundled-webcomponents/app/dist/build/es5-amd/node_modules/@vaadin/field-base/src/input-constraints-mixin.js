define(["exports", "../../../@polymer/polymer/lib/utils/mixin.js", "./delegate-state-mixin.js", "./input-mixin.js", "./validate-mixin.js"], function (_exports, _mixin, _delegateStateMixin, _inputMixin, _validateMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.InputConstraintsMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A mixin to combine multiple input validation constraints.
   *
   * @polymerMixin
   * @mixes DelegateStateMixin
   * @mixes InputMixin
   * @mixes ValidateMixin
   */
  var InputConstraintsMixin = (0, _mixin.dedupingMixin)(function (superclass) {
    return /*#__PURE__*/function (_DelegateStateMixin) {
      babelHelpers.inherits(InputConstraintsMixinClass, _DelegateStateMixin);

      var _super = _createSuper(InputConstraintsMixinClass);

      function InputConstraintsMixinClass() {
        babelHelpers.classCallCheck(this, InputConstraintsMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(InputConstraintsMixinClass, [{
        key: "ready",
        value:
        /** @protected */
        function ready() {
          babelHelpers.get(babelHelpers.getPrototypeOf(InputConstraintsMixinClass.prototype), "ready", this).call(this);

          this._createConstraintsObserver();
        }
        /**
         * Returns true if the current input value satisfies all constraints (if any).
         * @return {boolean}
         */

      }, {
        key: "checkValidity",
        value: function checkValidity() {
          var _this = this;

          if (this.inputElement && this._hasValidConstraints(this.constructor.constraints.map(function (c) {
            return _this[c];
          }))) {
            return this.inputElement.checkValidity();
          } else {
            return !this.invalid;
          }
        }
        /**
         * Returns true if some of the provided set of constraints are valid.
         * @param {Array} constraints
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_hasValidConstraints",
        value: function _hasValidConstraints(constraints) {
          var _this2 = this;

          return constraints.some(function (c) {
            return _this2.__isValidConstraint(c);
          });
        }
        /**
         * Override this method to customize setting up constraints observer.
         * @protected
         */

      }, {
        key: "_createConstraintsObserver",
        value: function _createConstraintsObserver() {
          // This complex observer needs to be added dynamically instead of using `static get observers()`
          // to make it possible to tweak this behavior in classes that apply this mixin.
          this._createMethodObserver("_constraintsChanged(".concat(this.constructor.constraints.join(', '), ")"));
        }
        /**
         * Override this method to implement custom validation constraints.
         * @param {unknown[]} constraints
         * @protected
         */

      }, {
        key: "_constraintsChanged",
        value: function _constraintsChanged() {
          // Prevent marking field as invalid when setting required state
          // or any other constraint before a user has entered the value.
          if (!this.invalid) {
            return;
          }

          for (var _len = arguments.length, constraints = new Array(_len), _key = 0; _key < _len; _key++) {
            constraints[_key] = arguments[_key];
          }

          if (this._hasValidConstraints(constraints)) {
            this.validate();
          } else {
            this.invalid = false;
          }
        }
        /**
         * Override an event listener inherited from `InputMixin`
         * to capture native `change` event and make sure that
         * a new one is dispatched after validation runs.
         * @param {Event} event
         * @protected
         * @override
         */

      }, {
        key: "_onChange",
        value: function _onChange(event) {
          event.stopPropagation();
          this.validate();
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              sourceEvent: event
            },
            bubbles: event.bubbles,
            cancelable: event.cancelable
          }));
        }
        /** @private */

      }, {
        key: "__isValidConstraint",
        value: function __isValidConstraint(constraint) {
          // 0 is valid for `minlength` and `maxlength`
          return Boolean(constraint) || constraint === 0;
        }
      }], [{
        key: "constraints",
        get:
        /**
         * An array of attributes which participate in the input validation.
         * Changing these attributes will cause the input to re-validate.
         *
         * IMPORTANT: The attributes should be properly delegated to the input element
         * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
         * The `required` attribute is already delegated.
         */
        function get() {
          return ['required'];
        }
      }, {
        key: "delegateAttrs",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(InputConstraintsMixinClass), "delegateAttrs", this)), ['required']);
        }
      }]);
      return InputConstraintsMixinClass;
    }((0, _delegateStateMixin.DelegateStateMixin)((0, _validateMixin.ValidateMixin)((0, _inputMixin.InputMixin)(superclass))));
  });
  _exports.InputConstraintsMixin = InputConstraintsMixin;
});