define(["exports", "../../../@polymer/polymer/lib/utils/mixin.js"], function (_exports, _mixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SlotStylesMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var stylesMap = new WeakMap();
  /**
   * Get all the styles inserted into root.
   * @param {DocumentOrShadowRoot} root
   * @return {Set<string>}
   */

  function getRootStyles(root) {
    if (!stylesMap.has(root)) {
      stylesMap.set(root, new Set());
    }

    return stylesMap.get(root);
  }
  /**
   * Insert styles into the root.
   * @param {string} styles
   * @param {DocumentOrShadowRoot} root
   */


  function insertStyles(styles, root) {
    var style = document.createElement('style');
    style.textContent = styles;

    if (root === document) {
      document.head.appendChild(style);
    } else {
      root.insertBefore(style, root.firstChild);
    }
  }
  /**
   * Mixin to insert styles into the outer scope to handle slotted components.
   * This is useful e.g. to hide native `<input type="number">` controls.
   *
   * @polymerMixin
   */


  var SlotStylesMixin = (0, _mixin.dedupingMixin)(function (superclass) {
    return /*#__PURE__*/function (_superclass) {
      babelHelpers.inherits(SlotStylesMixinClass, _superclass);

      var _super = _createSuper(SlotStylesMixinClass);

      function SlotStylesMixinClass() {
        babelHelpers.classCallCheck(this, SlotStylesMixinClass);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(SlotStylesMixinClass, [{
        key: "slotStyles",
        get:
        /**
         * List of styles to insert into root.
         * @protected
         */
        function get() {
          return {};
        }
        /** @protected */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(SlotStylesMixinClass.prototype), "connectedCallback", this).call(this);

          this.__applySlotStyles();
        }
        /** @private */

      }, {
        key: "__applySlotStyles",
        value: function __applySlotStyles() {
          var root = this.getRootNode();
          var rootStyles = getRootStyles(root);
          this.slotStyles.forEach(function (styles) {
            if (!rootStyles.has(styles)) {
              insertStyles(styles, root);
              rootStyles.add(styles);
            }
          });
        }
      }]);
      return SlotStylesMixinClass;
    }(superclass);
  });
  _exports.SlotStylesMixin = SlotStylesMixin;
});